import cells
import traceback
from cells.debug import debug_str
from cells.match import match_regex_str, CamelCaseLikeMatching

def match_regex_str_by_types(word, types):
    regexes = [ y for y in [match_regex_str(word, t) for t in types] if y != None]
    return'(?:'+ '|'.join(regexes)+')'

class CompletionWordsFromStr(object):
    """try to find sensible completions based on word
    """

    def __init__(self, word, types):
        super(CompletionWordsFromStr, self).__init__()
        self.re = re.compile('\\b('+ match_regex_str_by_types(word, types) +')')

    def all(self, s):
        return self.re.findall(s)


def match_by_type2(list, word):
  f = cells.match.match_score_function(word)
  for c in list:
    c.w = c.get('w', 0.9) * f(c['word'])
  return [c for c in list if c.w > 0]

def match_by_type(list, word, match_types):
    # use match_by_type2 instead
    regexes = []
    filtered = []

    if 'prefix' in match_types:
        regexes.append([re.compile('^'+word), 1])
    if 'prefix_ignore_case' in match_types:
        regexes.append([re.compile('^\c'+word), 1])
    if 'ycm' in match_types:
        # order of chars .., match case, then without match
        regexes.append([re.compile('^\c'+word), 1])
        regexes.append([re.compile('^\c'+word), 1])
    if len(word) <= 5 and 'camel_case_like' in match_types:
        regexes.append([re.compile("^"+CamelCaseLikeMatching(word)), 1])
    if len(regexes) == 0:
        cells.Log('no known match types found')
        # resort to prefix matching
        regexes.append([re.compile('^'+word), 1])

    for l in list:
        if not 'certainity' in l:
          l['certainity'] = 1
        c = 0
        for r in regexes:
            if r[0].match(l['word']):
                if r[1] > c:
                    c = r[1]
        if c > 0:
            filtered.append(l)

    return filtered

def call_vim(fun_str, args_array):
    to_vim([fun_str, args_array])
    import vim
    return vim.eval('cells#util#Call(g:to_vim[0], g:to_vim[1])')
    vim.Function(fun_str)(*args_array)

    # vim.command('call add(g:calls, ["%s", %s])' % (fun_str, str(args_array)))

def to_vim(x):
    import vim
    vim.Function('cells#util#ToVim')(x)

def eval(cmd):
    import vim
    import json
    return json.loads(vim.eval('cells#json#Encode(%s)'))


def emit_return(event):
    try:
        cells.py.cell_collection.emit_selector(event)
        return event
    except Exception as e:
        import traceback
        print(traceback.format_exc())
        raise e

def merge_dicts_cow(*args):
    d = {}
    for x in args:
        d.update(x)
    return d

def int_or_none(x):
    if x == None:
        return None
    return int(x)

def import_thing(n):
    try:
        module_and_class = n.split('.')
        module, clazz = ['.'.join(module_and_class[0:-1]), module_and_class[-1]]
        i = __import__(module)
        for p in module_and_class[1:-1]:
            i = getattr(i, p)
        thing = getattr(i, clazz)
        return thing
    except Exception as e:
        error = traceback.format_exc()
        debug_str(error)
        raise e
