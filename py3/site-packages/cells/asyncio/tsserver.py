#!/usr/bin/env python
import json
import tempfile

# https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29
# TSS_LOG
# [-level <terse | normal | requestTime | verbose>] 
# [-traceToConsole <true | false>] 
# [-logToFile <true | false>] 
# [-file <log file path>]

# --cancellationPipeName    : Name of the pipe used as a request cancellation semaphore. See Cancellation for more information.
# --eventPort               : Port used for receiving events. If non is specified events are sent to stdout.
# --useSingleInferredProject: Put all open .ts and .js files that do not have a .tsconfig file in a common project


# communication examples
# error message:
# Content-Length: 261
# {"seq":0,"type":"event","event":"semanticDiag","body":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts","diagnostics":[{"start":{"line":264,"offset":44},"end":{"line":264,"offset":50},"text":"Binding element 'Object' implicitly has an 'any' type."}]}}

# full liste of commands
# https://github.com/Microsoft/TypeScript/blob/master/lib/protocol.d.ts#L5

import traceback
import cells.asyncio as cells_a
import cells.util as util
import re
import os
import math
import glob
import os.path
import asyncio
from cells.debug import debug_str

class TSS


    def __init__(self, connection_properties, wait_for_server_messages = True):
        self.id = 1
        self.waiting = {}
        self.cp = connection_properties

        self.cancel_pipe_filename = mktemp()
        os.mkfifo(self.cancel_pipe_filename)
        self.cancel_pipe = open(self.cancel_pipe_filename, 'w')

        # server connection stuff
        self.tasks_to_kill_on_reconnect = {}
        self.writer = None
        self.reader = None
        self.wait_for_server_messages = wait_for_server_messages

        create = asyncio.create_subprocess_shell(self.cp['cmd'])
        process = await create
        self.reader, self.writer = process.stdout, process.stdin

        async def stderr_to_debug_s():
            debug_str(await process.stdout.readline())

class Tsserver(asyncio.Cell):

    def __init__(self, connection_properties, wait_for_server_messages = True):
        self.tss = TSS(connection_properties = connection_properties)


    # COMPLETION
    async def __completions(self, event):
        # await self.send_buf_updates(event['bufid'])

        lsac = event['event']['line_split_at_cursor']
        match = re.search('[a-zA-Z-_]*$', lsac[0]) # TODO unicode chars!
        word_before_cursor   = "" if match == None else match.group(0)
        word_before_cursor_1 = word_before_cursor

        r = await self.json_rcp.call(method = "textDocument/completion", params = await self.CursorContext_To_TextDocumentPositionParams(event['event']))
        debug_str("RESULT %s" % str(r))
        completions = [{'word': c['label'], 'w': 1.1, 'menu': c.get('detail', ''), 'kind' : c.get('kind', ''), 'info': c.get('documentation', '')} for c in r['result']['items']]

        completions = util.match_by_type2(completions, word_before_cursor)
        column = int(event['event']['position'][2]) - len(word_before_cursor)

        return [{
            'column': column + 1,
            'completions': completions
        }]

    async def l_completions(self, event):
        await event['async_def_result'](self.id, self.__completions(event))


    # DEFINITONS
    async def __definitions(self, event):

        r = await self.json_rcp.call(method = "textDocument/definition", params = [await self.CursorContext_To_TextDocumentPositionParams(event) ])
        script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
        definitions = script.goto_assignments(follow_imports=True)
        return [{'filepath': event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.doc, 'kind': 'JediCompletion'} for c in definitions]

    async def l_definitions(self, event):
        await event['async_def_result'](self.id, self.__definitions(event))


    # # USAGE
    # async def __usages(self, event):
    #     script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
    #     definitions = script.usages()
    #     return [{'filepath':  event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.doc, 'kind': 'JediCompletion'} for c in definitions]

    # async def l_usages(self, event):
    #     await event['async_def_result'](self.id, self.__usages(event))


#     # TYPE
#     async def __types(self, event):
#         script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
#         definitions = script.goto_assignments(follow_imports=True)
#         return [{'type': d.type ,'kind': 'JediCompletion'} for d in definitions]

#     async def l_types(self, event):
#         await event['async_def_result'](self.id, self.__types(event))


