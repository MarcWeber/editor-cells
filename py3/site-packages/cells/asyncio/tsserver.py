#!/usr/bin/env python
import json
import tempfile
print("SOURCI")
import cells.asyncio.error_line_parsers as elp

# featurers implemented:
# l_completion
# l_error (file list or project)
# l_definitions

# TODO: which tsconfig to be used.
# TODO: implement all features
#  - error lists (done)
#  - refactoring
#  - fix help
#  - thing below cursor info by bubbles
#  abort completion?
# ..

# https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29
# TSS_LOG
# [-level <terse | normal | requestTime | verbose>] 
# [-traceToConsole <true | false>] 
# [-logToFile <true | false>] 
# [-file <log file path>]

# --cancellationPipeName    : Name of the pipe used as a request cancellation semaphore. See Cancellation for more information.
# --eventPort               : Port used for receiving events. If non is specified events are sent to stdout.
# --useSingleInferredProject: Put all open .ts and .js files that do not have a .tsconfig file in a common project

# communication examples
# error message:
# Content-Length: 261
# {"seq":0,"type":"event","event":"semanticDiag","body":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts","diagnostics":[{"start":{"line":264,"offset":44},"end":{"line":264,"offset":50},"text":"Binding element 'Object' implicitly has an 'any' type."}]}}

# full list of commands
# https://github.com/Microsoft/TypeScript/blob/master/lib/protocol.d.ts#L5

# {"seq":1,"type":"quickinfo","command":"open","arguments":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts"}}
# TODO {"seq":1,"type":"quickinfo","command":"open","arguments":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts"}}
# {"seq":0,"type":"event","event":"semanticDiag","body":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts","diagnostics":[{"start":{"line":264,"offset":44},"end":{"line":264,"offset":50},"text":"Binding element 'Object' implicitly has an 'any' type."}]}}

import traceback
import cells.asyncio as cells_a
import cells.util as util
import re
import os
import math
import glob
import os.path
import asyncio
import tempfile

from cells.debug import debug_str
from cells.asyncio.jsonrpc import JsonRPC


class FilesState():
    """ remembers which files have been opened / updated at server """

    def __init__(self, cell, jsonrpc):
        self.cell = cell
        self.jsonrpc = jsonrpc
        self.files = {}

    async def prepare_file(self, filepath):
        temp = None
        if filepath in self.files:
            temp = self.files[filepath]
        else:
            temp = tempfile.mkstemp()[1]

        await self.cell.ask_editor_commands(commands = [{'save_as_tmp': temp}])

        if filepath in self.files:
            await self.jsonrpc.send_with_seq(** {'arguments':{'file':filepath, 'tmpfile': temp},'type': 'request','command':'reload'})
        else:
            await self.jsonrpc.send_with_seq(**{'arguments':{'file':filepath, 'tmpfile': temp},'type':'request','command':'open'})
            await self.jsonrpc.call(**{'arguments':{'file':filepath,'formatOptions':{'baseIndentSize':2 ,'indentSize':2,'convertTabsToSpaces':1},'hostInfo':"'100,<50,s10,h",'extraFileExtensions':[]},'type':'request','command':'configure'})
            self.files[filepath] = temp


# class TSS():
class Tsserver(cells_a.Cell):
    """ connects to tsserver and, tells which files to update and implements features such as completion """

    def __init__(self, *args, **kwargs):

        def log_writer(s):
            debug_str('tsserver write ' + str(s))
        def log_reader(s):
            debug_str('tsserver read ' + str(s))

        s = self

        self.reset_errors()

        def unexpected_message(r):
            # in err case
            # debugs unexpected message {'seq': 0, 'type': 'event', 'event': 'syntaxDiag', 'body': {'file': '/home/marc/editor-cells/tests/typescript/src/main.ts', 'diagnostics': [{'start': {'line': 4, 'offset': 7}, 'end': {'line': 4, 'offset': 7}, 'text': "')' expected.", 'code': 1005, 'category': 'error'}]}}
            # debugs unexpected message {'seq': 0, 'type': 'event', 'event': 'semanticDiag', 'body': {'file': '/home/marc/editor-cells/tests/typescript/src/main.ts', 'diagnostics': []}}

            # geterrForProject case I expect a list to be returned
            debug_str('>> got message %s '%(str(r)))
            if   r['event'] == 'syntaxDiag':
                self.errors['syntaxDiag']   = [r['body']] if type(r['body']) == type({}) else r['body']
            elif r['event'] == 'semanticDiag':
                self.errors['semanticDiag'] = [r['body']] if type(r['body']) == type({}) else r['body']
            else:
                debug_str('got unexpected message %s '%(str(r)))


            asyncio.Task(cells_a.emit({'type': 'quickfix_list_available', 'sender': self.id}))

        self.jsonrpc = JsonRPC(
            connection_properties = kwargs['connection_properties'],
            init_calls = [],
            log_writer = log_writer,
            log_reader = log_reader,
            id_key = "seq",
            reply_id_key = "request_seq",
            unexpected_message = unexpected_message
        )
        self.filesstate = FilesState(self, self.jsonrpc)
        super(Tsserver, self).__init__(*args, **kwargs)

    def reset_errors(self):
        self.errors = {'syntaxDiag': [], 'semanticDiag': []}

    # COMPLETION
    async def __completions(self, event):
        await self.filesstate.prepare_file(event['filepath'])
        lsac = event['line_split_at_cursor']
        match = re.search('[a-zA-Z-_]*$', lsac[0]) # TODO unicode chars!
        word_before_cursor   = "" if match == None else match.group(0)
        word_before_cursor_1 = word_before_cursor

        r = await self.jsonrpc.call(command = "completions", arguments = {'file': event['filepath'], 'line': event['position'][1], 'offset': event['position'][2], 'prefix': word_before_cursor[:1]})
        debug_str("RESULT %s" % str(r))

        #  {'seq': 0, 'type': 'response', 'command': 'completions', 'request_seq': 3, 'success': True, 'body': [{'name': 'ANGLE_instanced_arrays', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'ActiveXObject', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AnalyserNode', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AnimationEvent', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'ApplicationCache', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'Array', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'ArrayBuffer', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'Attr', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'Audio', 'kind': 'var', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioBuffer', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioBufferSourceNode', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioContext', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioDestinationNode', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioListener', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioNode', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioParam', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioProcessingEvent', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioTrack', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioTrackList', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'BarProp', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'BeforeUnloadEvent', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'BiquadFilterNode', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'Blob', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'Boolean', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'BroadcastChannel', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CDATASection', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSS', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSConditionRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSFontFaceRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSGroupingRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSImportRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSKeyframeRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSKeyframesRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSMediaRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText':
        if not r['success']:
            return []

        completions = [{'word': c['name']+( "(" if c['kind'] in ['function','method'] else "") , 'w': 99999, 'menu': str(c), 'kind' : 'Tsserver' , 'info': c['kind']} for c in r['body']]

        completions = util.match_by_type2(completions, word_before_cursor)
        column = int(event['position'][2]) - len(word_before_cursor)

        return [{
            'column': column,
            'completions': completions
        }]

    async def l_completions(self, event):
        await event['async_def_result'](self.id, self.__completions(event['event']))


    # DEFINITONS
    async def __definitions(self, event):
        debug_str("l_definitions")
        await self.filesstate.prepare_file(event['filepath'])

        [implementations, typeDefinitions, definitions] = await asyncio.gather(
            self.jsonrpc.call(command = "implementation", type ='request', arguments = {'file': event['filepath'], 'line': event['position'][1], 'offset': event['position'][2]}),
            self.jsonrpc.call(command = "typeDefinition", type ='request', arguments = {'file': event['filepath'], 'line': event['position'][1], 'offset': event['position'][2]}),
            self.jsonrpc.call(command = "definition",     type ='request', arguments = {'file': event['filepath'], 'line': event['position'][1], 'offset': event['position'][2]})
        )
        debug_str("RESULTs %s" % str( [ implementations, typeDefinitions, definitions ]))

        unique = [json.loads(s) for s in set([json.dumps(d) for d in implementations['body'] + typeDefinitions['body'] + definitions['body']])]

        #   [{'file': 'hogehoge.ts', 'start': {'line': 3, 'offset': 2}, 'end': {'line': 3, 'offset': 10}}]
        return [{'filepath': c['file'], 'line': c['start']['line'], 'column': c['start']['offset']} for c in unique]

    async def l_definitions(self, event):
        await event['async_def_result'](self.id, self.__definitions(event))


    # renaming / refactoring
    async def l_rename(self, event):
       # event.findInComments
       # event.findInString
       # event.newSymbol old symbol to be replaced by this
       pos = event['position']
       # let l:res_dict = tsuquyomi#tsClient#tsRename(l:filename, l:line, l:offset, a:findInComments, a:findInString)
       r = await self.jsonrpc.call(command = "rename", type ='request', arguments = {'file': event['filepath'], 'line': event['position'][1], 'offset': event['position'][2], 'findInComments' : event.get('findInComments'), 'findInString' : event.get('findInString'), 'replaceWith' : event.get('replaceWith')})
       debug_str("RESULTs %s" % str(r))

    # errors
    async def l_quickfix_list(self, event):
       #    {'file': '/home/marc/editor-cells/tests/typescript/src/main.ts', 'diagnostics': [{'start': {'line': 4, 'offset': 7}, 'end': {'line': 4, 'offset': 7}, 'text': "')' expected.", 'code': 1005, 'category': 'error'}
        categories = {'error': 'E'}

        list = []
        def add_errors(c):
            for y in self.errors[c]:
                for x in y['diagnostics']:
                    if not x['category'] in categories:
                        print('tsserver.py new category %s' % x['category']) # map to quickfix error types

                    text_lines = x['text'].split("\n")
                    item = {'filename': y['file'], 'text': text_lines[0], 'col': x['start']['offset'], 'lnum': x['start']['line'], 'type' : categories[x['category']]}
                    list.append(item)
                    for l in text_lines[1:]:
                        list.append({'text': l})
                    # list.append(item)
                    # if elp.tss_is_not_assignable(x['text'], list) or elp.tss_comp_types(x['text'], list):
                    #     item['text'] = ''

        add_errors('syntaxDiag')
        add_errors('semanticDiag')


        debug_str("IN l_quickfix_list returning list %s" % (str(list)))
        # return self.error_list
        event['reply_now'](self.id, {'truncated': False, 'list': list })

    async def __errors(self, event):
        if 'for_filepaths' in event:
            await asyncio.gather(*[self.filesstate.prepare_file(f) for f in event['for_filepaths']])
            r = await self.jsonrpc.call(command = "geterr", arguments = {'delay': 0, 'files': event['for_filepaths']})
            self.error_list = r
            debug_str("RESULTs %s" % str(0))
        else:
            await self.filesstate.prepare_file(self.current_filepath)
            r = await self.jsonrpc.call(command = "geterrForProject", arguments = {'delay': 0, 'file': event['filepath']})
            self.error_list = r
            debug_str("RESULTs %s" % str(0))
        asyncio.Task(cells_a.emit({'type': 'quickfix_list_available', 'sender': self.id}))

    async def l_errors(self, event):
        # event = {} -> all errors
        # event = {'for_filepaths': []} -> only show for those paths
        self.reset_errors()
        asyncio.Task(self.__errors(event))

    async def l_editor_bufenter(self, event):
        self.current_filepath = event["filepath"]


    async def l_editor_bufwritepost(self, event):
        self.reset_errors()
        asyncio.Task(self.__errors({'for_filepaths': [event['filepath']]}))


    # # USAGE
    # async def __usages(self, event):
    #     script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
    #     definitions = script.usages()
    #     return [{'filepath':  event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.doc, 'kind': 'JediCompletion'} for c in definitions]

    # async def l_usages(self, event):
    #     await event['async_def_result'](self.id, self.__usages(event))


#     # TYPE
#     async def __types(self, event):
#         script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
#         definitions = script.goto_assignments(follow_imports=True)
#         return [{'type': d.type ,'kind': 'JediCompletion'} for d in definitions]

#     async def l_types(self, event):
#         await event['async_def_result'](self.id, self.__types(event))


