#!/usr/bin/env python
import json
import tempfile

# https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29
# TSS_LOG
# [-level <terse | normal | requestTime | verbose>] 
# [-traceToConsole <true | false>] 
# [-logToFile <true | false>] 
# [-file <log file path>]

# --cancellationPipeName    : Name of the pipe used as a request cancellation semaphore. See Cancellation for more information.
# --eventPort               : Port used for receiving events. If non is specified events are sent to stdout.
# --useSingleInferredProject: Put all open .ts and .js files that do not have a .tsconfig file in a common project


# communication examples
# error message:
# Content-Length: 261
# {"seq":0,"type":"event","event":"semanticDiag","body":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts","diagnostics":[{"start":{"line":264,"offset":44},"end":{"line":264,"offset":50},"text":"Binding element 'Object' implicitly has an 'any' type."}]}}

# full list of commands
# https://github.com/Microsoft/TypeScript/blob/master/lib/protocol.d.ts#L5

# {"seq":1,"type":"quickinfo","command":"open","arguments":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts"}}
# TODO {"seq":1,"type":"quickinfo","command":"open","arguments":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts"}}
# {"seq":0,"type":"event","event":"semanticDiag","body":{"file":"c:/DefinitelyTyped/gregorian-calendar/index.d.ts","diagnostics":[{"start":{"line":264,"offset":44},"end":{"line":264,"offset":50},"text":"Binding element 'Object' implicitly has an 'any' type."}]}}

import traceback
import cells.asyncio as cells_a
import cells.util as util
import re
import os
import math
import glob
import os.path
import asyncio
import tempfile

from cells.debug import debug_str
from cells.asyncio.jsonrpc import JsonRPC


class FilesState():

    def __init__(self, cell, jsonrpc):
        self.cell = cell
        self.jsonrpc = jsonrpc
        self.files = {}

    async def prepare_file(self, filepath):
        temp = tempfile.mkstemp()[1]
        results = await self.cell.ask_editor_commands(commands = [{'save_as_tmp': temp}])
        debug_str("11")
        if filepath in self.files:
            await self.jsonrpc.send_with_seq(** {'arguments':{'file':filepath, 'tmpfile': temp},'type': 'request','command':'reload'})
        else:
            await self.jsonrpc.send_with_seq(**{'arguments':{'file':filepath},'type':'request','command':'open'})
            await self.jsonrpc.call(**{'arguments':{'file':filepath,'formatOptions':{'baseIndentSize':2 ,'indentSize':2,'convertTabsToSpaces':1},'hostInfo':"'100,<50,s10,h",'extraFileExtensions':[]},'type':'request','command':'configure'})
            self.files[filepath] = True
        debug_str("removing")
        os.remove(temp)


# class TSS():
class Tsserver(cells_a.Cell):

    def __init__(self, *args, **kwargs):

        def log_writer(s):
            debug_str(s)
        log_reader = None

        async def async_log_unexpected_message(s):
            # maybe this is too noisy
            debug_str(s)


        self.jsonrpc = JsonRPC(
            connection_properties = kwargs['connection_properties'],
            init_calls = [],
            log_writer = log_writer,
            log_reader = log_reader,
            async_log_unexpected_message = async_log_unexpected_message,
            id_key = "seq",
            reply_id_key = "request_seq"
        )
        self.filesstate = FilesState(self, self.jsonrpc)
        debug_str("__init__ compltee")
        super(Tsserver, self).__init__(*args, **kwargs)


    # COMPLETION
    async def __completions(self, event):
        debug_str("preparing")
        await self.filesstate.prepare_file(event['filepath'])
        debug_str("after prepare_file")
        lsac = event['line_split_at_cursor']
        match = re.search('[a-zA-Z-_]*$', lsac[0]) # TODO unicode chars!
        word_before_cursor   = "" if match == None else match.group(0)
        word_before_cursor_1 = word_before_cursor

        debug_str("completing")
        r = await self.jsonrpc.call(command = "completions", arguments = {'file': event['filepath'], 'line': event['position'][1], 'offset': event['offset'], 'prefix': word_before_cursor[:1]})
        debug_str("RESULT %s" % str(r))

        #  {'seq': 0, 'type': 'response', 'command': 'completions', 'request_seq': 3, 'success': True, 'body': [{'name': 'ANGLE_instanced_arrays', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'ActiveXObject', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AnalyserNode', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AnimationEvent', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'ApplicationCache', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'Array', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'ArrayBuffer', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'Attr', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'Audio', 'kind': 'var', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioBuffer', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioBufferSourceNode', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioContext', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioDestinationNode', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioListener', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioNode', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioParam', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioProcessingEvent', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioTrack', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'AudioTrackList', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'BarProp', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'BeforeUnloadEvent', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'BiquadFilterNode', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'Blob', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'Boolean', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'BroadcastChannel', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CDATASection', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSS', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSConditionRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSFontFaceRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSGroupingRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSImportRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSKeyframeRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSKeyframesRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText': '0'}, {'name': 'CSSMediaRule', 'kind': 'interface', 'kindModifiers': 'declare', 'sortText':
        if not r['success']:
            return []

        completions = [{'word': c['name']+( "(" if c['kind'] == 'function' else "") , 'w': 1.1, 'menu': str(c), 'kind' : c['kind'], 'info': ''} for c in r['body']]

        debug_str("before curso %s" % str(word_before_cursor))
        completions = util.match_by_type2(completions, word_before_cursor)
        column = int(event['position'][2]) - len(word_before_cursor)

        return [{
            'column': column,
            'completions': completions
        }]

    async def open(self, event):
        debug_str(str(event))
        filepath = event['filepath']
        await self.jsonrpc.send(method = "open", params = {"textDocument":{"uri": uri,"languageId":"php","version":1, "text": "\n".join(lines)}})

    async def l_completions(self, event):
        # await self.open(event['event'])
        await event['async_def_result'](self.id, self.__completions(event['event']))


    # DEFINITONS
    async def __definitions(self, event):

        r = await self.json_rcp.call(method = "textDocument/definition", params = [await self.CursorContext_To_TextDocumentPositionParams(event) ])
        script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
        definitions = script.goto_assignments(follow_imports=True)
        return [{'filepath': event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.doc, 'kind': 'JediCompletion'} for c in definitions]

    async def l_definitions(self, event):
        await event['async_def_result'](self.id, self.__definitions(event))


    # # USAGE
    # async def __usages(self, event):
    #     script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
    #     definitions = script.usages()
    #     return [{'filepath':  event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.doc, 'kind': 'JediCompletion'} for c in definitions]

    # async def l_usages(self, event):
    #     await event['async_def_result'](self.id, self.__usages(event))


#     # TYPE
#     async def __types(self, event):
#         script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
#         definitions = script.goto_assignments(follow_imports=True)
#         return [{'type': d.type ,'kind': 'JediCompletion'} for d in definitions]

#     async def l_types(self, event):
#         await event['async_def_result'](self.id, self.__types(event))


