#!/usr/bin/env python
import json
import tempfile
print("SOURCI")

# featurers implemented:
# run webpack --watch
# whenever there are new errors feed them to quickfix
# requires cells#viml#quickfix#Trait cell running
# call g:bridge_cell.cell_new_by_name({'name': 'cells.asyncio.watch_cmd_errors.Webpack_watch', 'args': [], 'kwargs': {'cmd': 'webpack --watch'}})

# TODO generalise this..

import traceback
import cells.asyncio as cells_a
import cells.util as util
import re
import os
import math
import glob
import os.path
import asyncio
import tempfile
import cells.asyncio.error_line_parsers as elp

from cells.debug import debug_str
from cells.asyncio.jsonrpc import JsonRPC

class WatchCmdErrors():
    """
    runs external command and tryies to figure out on its own when to feed a
    error list' to Vim's Quickfix list

    Some commands like webpack --watch's recompilation cycle will be triggered by
    file changes. Others can be triggred by you.

    kwargs: {
        'sleep_time': 0.2,
        'error_line_parsers': [
            'cells.asyncio.error_line_parsers.line_parser_ruby_ignore_warning',
            'cells.asyncio.error_line_parsers.line_parser_ruby',
            'cells.asyncio.error_line_parsers.line_parser_webpack',
            'cells.asyncio.error_line_parsers.line_parser_consume_line',
        ]
    }
    """

    def __init__(self, *args, **kwargs):
        super(Webpack_watch, self).__init__(*args, **kwargs)
        self.reset_lines()
        asyncio.Task(self.forever_read(kwargs['cmd']))
        self.line_parsers = []

        self.sleep_time = kwargs.get('sleep_time', 0.2)

        for k in kwargs.get*('error_line_parsers', []):
            self.line_parsers.append(cells.util.import_thing(k))
        self.line_parsers.append(self.line_parser_consume_line)

    async def lines_to_qf(self):
        await asyncio.sleep(self.sleep_time)
        # wasn't killed, submit lines
        asyncio.Task(cells_a.emit({'type': 'quickfix_list_available', 'sender': self.id}))

    # errors
    async def l_quickfix_list(self, event):
        list = to_vim([], self.lines)
        event['reply_now'](self.id, {'truncated': False, 'list': list })

    async def forever_read(self, cmd):
        create = asyncio.create_subprocess_shell(cmd, stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE)
        process = await create

        self.reader, self.writer = process.stdout, process.stdin
        if self.writer == None:
            raise Exception('Something failed')

        self.task = None
        new_run = re.compile("^Version: webpack")
        while True:
            l = await self.reader.readline()
            l = l.decode('utf-8')
            if new_run.match(l):
                self.reset_lines()
            self.lines.append(l)
            if self.task != None:
                self.task.cancel()
            self.task = asyncio.Task(self.lines_to_qf())

    def reset_lines(self):
        self.lines = []



class Webpack_watch(cells_a.Cell):
    # deprecated, rewrite using WatchCmdErrors

    def __init__(self, *args, **kwargs):
        super(Webpack_watch, self).__init__(*args, **kwargs)
        self.reset_lines()
        asyncio.Task(self.forever_read(kwargs['cmd']))


    async def lines_to_qf(self):
        await asyncio.sleep(0.2)
        # wasn't killed, submit lines
        asyncio.Task(cells_a.emit({'type': 'quickfix_list_available', 'sender': self.id}))


    # errors
    async def l_quickfix_list(self, event):
        list = elp.to_vim([elp.line_parser_webpack, elp.line_parser_consume_line], self.lines)
        event['reply_now'](self.id, {'truncated': False, 'list': list })

    async def forever_read(self, cmd):
        create = asyncio.create_subprocess_shell(cmd, stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE)
        process = await create

        self.reader, self.writer = process.stdout, process.stdin
        if self.writer == None:
            raise Exception('Something failed')

        self.task = None
        new_run = re.compile("^Version: webpack")
        while True:
            l = await self.reader.readline()
            l = l.decode('utf-8')
            if new_run.match(l):
                self.reset_lines()
            self.lines.append(l)
            if self.task != None:
                self.task.cancel()
            self.task = asyncio.Task(self.lines_to_qf())


    def reset_lines(self):
        self.lines = []

