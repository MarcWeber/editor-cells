#!/usr/bin/env python
import json
import tempfile

# featurers implemented:
# run webpack --watch
# whenever there are new errors feed them to quickfix
# requires cells#viml#quickfix#Trait cell running
# call g:bridge_cell.cell_new_by_name({'name': 'cells.asyncio.watch_cmd_errors.Webpack_watch', 'args': [], 'kwargs': {'cmd': 'webpack --watch'}})

# TODO generalise this..

import traceback
import cells.asyncio as cells_a
import cells.util as util
import re
import os
import math
import glob
import os.path
import asyncio
import tempfile
import cells.asyncio.error_line_parsers as elp

from cells.debug import debug_str
from cells.asyncio.jsonrpc import JsonRPC

class WatchCmdErrors(cells_a.Cell):
    """
    runs external command and tryies to figure out on its own when to feed a
    error list' to Vim's Quickfix list

    Some commands like webpack --watch's recompilation cycle will be triggered by
    file changes. Others can be triggred by you.

    kwargs: {
        'sleep_time': 0.2,
        'error_line_parsers': [
            'cells.asyncio.error_line_parsers.line_parser_ruby_ignore_warning',
            'cells.asyncio.error_line_parsers.line_parser_ruby',
            'cells.asyncio.error_line_parsers.line_parser_webpack',
            'cells.asyncio.error_line_parsers.line_parser_consume_line',
        ]
    }


    Example: using irb script
    new_run_regex -> if this is found error list gets reset, its a python re regular expression

    let load_cmd =  'load "foo.rb"\n'
    let error_line_parsers = [
    \         'cells.asyncio.error_line_parsers.line_parser_ruby_ignore_warning',
    \         'cells.asyncio.error_line_parsers.line_parser_ruby',
    \ ]
    call g:bridge_cell.cell_new_by_name({'name': 'cells.asyncio.watch_cmd_errors.WatchCmdErrors', 'args': [], 'kwargs': {'header': 'headline','id': 'py:external_process', 'cmd': 'irb', 'new_run_regex': '^Version: webpack', 'stdin_data': load_cmd, 'error_line_parsers' : error_line_parsers}})
    nnoremap <F2> :call setqflist([])<bar>call cells.emit({'type': 'stdin_write', 'stdin_data': g:load_cmd, 'reset': true, 'selector': {"id": 'py:external_process'}})<cr>

    TODO: add relaunch or make things simple and get 'errors' from file
    """

    def __init__(self, *args, **kwargs):
        super(WatchCmdErrors, self).__init__(*args, **kwargs)
        self.reset_lines()
        asyncio.Task(self.forever_read(kwargs['cmd']))
        self.line_parsers = []

        self.sleep_time = kwargs.get('sleep_time', 0.2)
        self.new_run_regex = kwargs.get('new_run_regex', 0.2)

        for k in kwargs.get('error_line_parsers', []):
            self.line_parsers.append(util.import_thing(k))
        self.line_parsers.append(elp.line_parser_consume_line)

    async def lines_to_qf(self):
        await asyncio.sleep(self.sleep_time)
        # wasn't killed, submit lines
        asyncio.Task(cells_a.emit({'type': 'quickfix_list_available', 'sender': self.id}))

    # errors
    async def l_quickfix_list(self, event):
        list = elp.to_vim(self.line_parsers, self.lines)
        if (hasattr(self, 'header')):
            list.insert(0, {'text': self.header})
        event['reply_now'](self.id, {'truncated': False, 'list': list })

    async def forever_read(self, cmd):
        create = asyncio.create_subprocess_shell(cmd, stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE)
        process = await create

        self.reader, self.writer = process.stdout, process.stdin
        if self.writer == None:
            raise Exception('Something failed')

        if self.stdin_data != None:
            self.send_stdin(self.stdin_data)

        self.task = None
        new_run = re.compile(self.new_run_regex)
        while True:
            l = await self.reader.readline()
            l = l.decode('utf-8')
            if new_run.match(l):
                self.reset_lines()
            self.lines.append(l)
            if self.task != None:
                self.task.cancel()
            self.task = asyncio.Task(self.lines_to_qf())

    def reset_lines(self):
        self.lines = []

    # send stdin
    async def l_stdin_write(self, event):
        if event.get('reset', False):
            self.reset_lines()
        self.send_stdin(event['stdin_data'])

    def send_stdin(self, data):
        # debug_str("sending data to stdin: %s" % str(data))
        self.writer.write(data.encode('utf-8'))


class Webpack_watch(cells_a.Cell):
    # deprecated, rewrite using WatchCmdErrors

    def __init__(self, *args, **kwargs):
        super(Webpack_watch, self).__init__(*args, **kwargs)
        self.reset_lines()
        asyncio.Task(self.forever_read(kwargs['cmd']))


    async def lines_to_qf(self):
        await asyncio.sleep(0.2)
        # wasn't killed, submit lines
        asyncio.Task(cells_a.emit({'type': 'quickfix_list_available', 'sender': self.id}))


    # errors
    async def l_quickfix_list(self, event):
        list = elp.to_vim([elp.line_parser_webpack, elp.line_parser_consume_line], self.lines)
        event['reply_now'](self.id, {'truncated': False, 'list': list })

    async def forever_read(self, cmd):
        create = asyncio.create_subprocess_shell(cmd, stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE)
        process = await create

        self.reader, self.writer = process.stdout, process.stdin
        if self.writer == None:
            raise Exception('Something failed')

        self.task = None
        new_run = re.compile("^Version: webpack")
        while True:
            l = await self.reader.readline()
            l = l.decode('utf-8')
            if new_run.match(l):
                self.reset_lines()
            self.lines.append(l)
            if self.task != None:
                self.task.cancel()
            self.task = asyncio.Task(self.lines_to_qf())


    def reset_lines(self):
        self.lines = []
