#!/usr/bin/env python
import json
import tempfile
print("SOURCI")

# featurers implemented:
# run webpack --watch
# whenever there are new errors feed them to quickfix
# requires cells#viml#quickfix#Trait cell running
# Example: call g:bridge_cell.cell_new_by_name({'name': 'cells.asyncio.watch_cmd_errors.Webpack_watch', 'args': [], 'kwargs': {'cmd': 'webpack --watch'}})

# TODO generalise this..

import traceback
import cells.asyncio as cells_a
import cells.util as util
import re
import os
import math
import glob
import os.path
import asyncio
import tempfile

from cells.debug import debug_str
from cells.asyncio.jsonrpc import JsonRPC

class Webpack_watch(cells_a.Cell):

    def __init__(self, *args, **kwargs):
        super(Webpack_watch, self).__init__(*args, **kwargs)

        self.reset_lines()

        asyncio.Task(self.forever_read(kwargs['cmd']))


    async def lines_to_qf(self):
        await asyncio.sleep(0.5)
        # wasn't killed, submit lines
        asyncio.Task(cells_a.emit({'type': 'quickfix_list_available', 'sender': self.id}))


    # errors
    async def l_quickfix_list(self, event):
        list = []

        re_tsl_line = re.compile('.*\[tsl\] ERROR in ([^(]*)\(([^,]*),([^,]*)\)')
        i = 0
        while i < len(self.lines):
            match = re_tsl_line.match(self.lines[i])
            if (match):
                i+=1
                message = self.lines[i]
                list.append({'filename': match.group(1), 'text': message, 'col': match.group(3), 'lnum': match.group(2), 'type' : 'E'})
            else:
                list.append({'text': self.lines[i]})
            i+=1

        debug_str('list==')
        debug_str(str(list))
        event['reply_now'](self.id, {'truncated': False, 'list': list })

    async def forever_read(self, cmd):
        create = asyncio.create_subprocess_shell(cmd, stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE)
        process = await create

        self.reader, self.writer = process.stdout, process.stdin
        if self.writer == None:
            raise Exception('Something failed')

        self.task = None
        new_run = re.compile("^Version: webpack")
        while True:
            l = await self.reader.readline()
            l = l.decode('utf-8')
            if new_run.match(l):
                self.reset_lines()
            self.lines.append(l)
            if self.task != None:
                self.task.cancel()
            self.task = asyncio.Task(self.lines_to_qf())


    def reset_lines(self):
        self.lines = []

