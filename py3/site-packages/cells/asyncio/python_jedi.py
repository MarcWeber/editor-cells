#!/usr/bin/env python

# Jedi support
# jedi might support more python versions
# using jedi this way you need to use same version as the python interpreter
# this class runs in
# https://jedi.readthedocs.io/en/latest/docs/plugin-api.html

import cells.asyncio as cells_a
import cells.util as util
import re
import math
import glob
import os.path
import asyncio
from cells.debug import debug_str

import jedi.api

class JediCompletion(cells_a.Cell):
    """provide completions based on files"""

    def __init__(self, *args, **kwargs):
        super(JediCompletion, self).__init__(*args, **kwargs)

    async def __script(self, event, column = None, line = None):
        lines = await self.ask_editor_commands(commands = [{'lines_of_buf_id':'%'}])
        lines = lines[0][0]
        debug_str(" lines %s" % lines)
        
        return jedi.api.Script(
                source = "\n".join(lines),
                line = line,
                column = column,
                sys_path = self.sys_path if hasattr(self,'sys_path') else None
                )

    # COMPLETION
    async def __completions(self, event):
        debug_str("in __completions")
        words_ = re.split('[ \t\r\n.{}()<>\'"]', event['event']['line_split_at_cursor'][0])
        word_before_cursor = words_[-1]

        line = int(event['event']['position'][1])
        column = int(event['event']['position'][2])-1-len(word_before_cursor)
        script = await self.__script(event, line = line, column = column)
        completions = script.completions()
        # c.column              c.doc                 c.full_name           c.in_builtin_module  c.module_name         c.name_with_symbols   c.raw_doc             
        # c.complete            c.docstring(          c.get_line_code(      c.is_keyword          c.module_path         c.params              c.type                
        # c.description         c.follow_definition(  c.goto_assignments(   c.line                c.name                c.parent(     

        # column():4
        # complete:removedirs
        # description:def removedirs
        # doc:removedirs(name)

        # removedirs(name)

        # Super-rmdir; remove a leaf directory and all empty intermediate
        # ones.  Works like rmdir except that, if the leaf directory is
        # successfully removed, directories corresponding to rightmost path
        # segments will be pruned away until either the whole path is
        # consumed or an error occurs.  Errors during this latter phase are
        # ignored -- they generally mean that a directory was not empty.
        # docstring():<bound method Completion.docstring of <Completion: removedirs>>
        # follow_definition():<bound method memoize_method.<locals>.wrapper of <Completion: removedirs>>
        # full_name:os.removedirs
        # get_line_code():<bound method BaseDefinition.get_line_code of <Completion: removedirs>>
        # goto_assignments():<bound method BaseDefinition.goto_assignments of <Completion: removedirs>>
        # in_builtin_module():<bound method BaseDefinition.in_builtin_module of <Completion: removedirs>>
        # is_keyword():False
        # line():227
        # module_name:os
        # module_path:/nix/store/hd0h2indcv2zxbgxy021yv1z82jyivsc-python3-3.6.1/lib/python3.6/os.py
        # name:removedirs
        # name_with_symbols:removedirs
        # params():[<_Param param name>]
        # parent():<bound method BaseDefinition.parent of <Completion: removedirs>>
        # raw_doc:removedirs(name)

        # Super-rmdir; remove a leaf directory and all empty intermediate
        # ones.  Works like rmdir except that, if the leaf directory is
        # successfully removed, directories corresponding to rightmost path
        # segments will be pruned away until either the whole path is
        # consumed or an error occurs.  Errors during this latter phase are
        # ignored -- they generally mean that a directory was not empty.
        # type:function



        match_str = util.match_regex_str_by_types(word_before_cursor, event['event']['match_types'])
        re_match = re.compile('^'+match_str)
        # don't know how to sort
        re_param_match = re.compile('<_Param param (.*)>')
        def p_to_str(p):
            # <_Param param device special file or named pipe>
            return re_param_match.match(str(p)).group(1).replace(' ', '_')

        def params_to_str(c):
            try:
                return "(%s)" % ", ".join([p_to_str(x) for x in c.params])
            except Exception as e:
                params = "no parameters %s" % str(e)
                return ""

        def info(c):
            params = None
            try:
                params = str(c.params)
            except Exception as e:
                params = ""

            return "params: %s\nmodule_path: %s:%s\n%s" % (params_to_str(c), c.module_path, c.line, c.docstring())

        def all_completion_attrs_to_str(c):
            ls = []
            for x in dir(c):
                if x[0] != '_':
                    try:
                        attr = getattr(c, x)
                        if type(attr) == type(""):
                            ls.append("%s:%s" % (x, attr))
                        else:
                            ls.append("%s():%s" % (x, attr))
                    except Exception as e:
                        ls.append("%s(): attribute error while accessing %s" % (x, str(e)))
            return "\n".join(ls)

        debug_str(" completions %s" % str(completions))
        completions = [{'word': c.name, 'w': 1.1, 'menu': "from %s" % c.module_name, 'kind' : c.type, 'description': c.docstring(), 'info': info(c) } for c in completions if re_match.match(c.name)]

        return [{
            'column': column + 1,
            'completions': completions
        }]

    async def l_completions(self, event):
        await event['async_def_result'](self.id, self.__completions(event))


    # DEFINITONS
    async def __definitions(self, event):
        script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
        definitions = script.goto_assignments(follow_imports=True)
        return [{'filepath': event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.docstring(), 'kind': 'JediCompletion'} for c in definitions]

    async def l_definitions(self, event):
        await event['async_def_result'](self.id, self.__definitions(event))


    # USAGE
    async def __usages(self, event):
        script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
        definitions = script.usages()
        return [{'filepath':  event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.docstring(), 'kind': 'JediCompletion'} for c in definitions]

    async def l_usages(self, event):
        await event['async_def_result'](self.id, self.__usages(event))


    # TYPE
    async def __types(self, event):
        script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
        definitions = script.goto_assignments(follow_imports=True)
        return [{'type': d.type ,'kind': 'JediCompletion'} for d in definitions]

    async def l_types(self, event):
        await event['async_def_result'](self.id, self.__types(event))

