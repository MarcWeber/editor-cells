#!/usr/bin/env python

# Jedi support
# jedi might support more python versions
# using jedi this way you need to use same version as the python interpreter
# this class runs in

import cells.asyncio as cells_a
import cells.util as util
import cells.asyncio.native
import re
import math
import glob
import os.path
import asyncio

import jedi.api

class JediCompletion(cells_a.Cell):
    """provide completions based on files"""

    def __init__(self, *args, **kwargs):
        cells.asyncio.native.NativeEditorImplementation()
        super(JediCompletion, self).__init__(*args, **kwargs)

    async def __script(self, event, column = None, line = None):
        lines = await self.ask({'type': 'py_editor_buffer_lines'})
        lines = lines[0]
        return jedi.api.Script(
                source = "\n".join(lines),
                line = line,
                column = column,
                sys_path = self.sys_path if hasattr(self,'sys_path') else None
                )

    async def __completions(self, event):
        words_ = re.split('[ \t\r\n.{}()<>\'"]', event['event']['line_split_at_cursor'][0])
        word_before_cursor = words_[-1]

        line = int(event['event']['position'][1])
        column = int(event['event']['position'][2])-1-len(word_before_cursor)
        script = await self.__script(event, line = line, column = column)
        completions = script.completions()
        # c.column              c.doc                 c.full_name           c.in_builtin_module  c.module_name         c.name_with_symbols   c.raw_doc             
        # c.complete            c.docstring(          c.get_line_code(      c.is_keyword          c.module_path         c.params              c.type                
        # c.description         c.follow_definition(  c.goto_assignments(   c.line                c.name                c.parent(     


        match_str = util.match_regex_str_by_types(word_before_cursor, event['event']['match_types'])
        re_match = re.compile('^'+match_str)
        # don't know how to sort
        def info(c):
            ls = []
            for x in dir(c):
                if x[0] != '_':
                    try:
                        attr = getattr(c, x)
                        if type(attr) == type(""):
                            ls.append("%s:%s" % (x, attr))
                        else:
                            ls.append("%s():%s" % (x, attr))
                    except Exception as e:
                        ls.append("%s(): attribute error while accessing %s" % (x, str(e)))
            return "\n".join(ls)

        completions = [{'word': c.name , 'w': 1.1, 'kind' : c.type, 'description': c.doc, 'menu': info(c) } for c in completions if re_match.match(c.name)]

        return [{
            'column': column + 1,
            'completions': completions
        }]


    async def l_completions(self, event):
        await event['async_def_result'](self.id, self.__completions(event))

    async def __info_about_thing_at_cursor(self, event):
        script = await self.__script(event, line = line, column = column)
        # completions = script.completions()
        return things #

    async def l_info_about_thing_at_cursor (self, event):
        await event['async_def_result'](self.id, self.__info_about_thing_at_cursor(event))
