# Python implementation - asyncio version, requires Python3
import copy
import sys
import copy
import cells
import asyncio
import traceback

if not 'cells' in locals():
    cells = {}

debug = False
cell_collection = None

def debug_str(s):
    # f = open('/tmp/zzz', 'a')
    # f.write("debugs %s\n"% s)
    # f.close()
    if debug:
        sys.stderr.write("%s" % s)

class CellCollection:
    """Events will be sent to the cells contained in this collection"""

    def __init__(self, prefix):
        """@todo: to be defined1. """
        self.prefix = prefix
        self.cells = {}
        self.next_id = 0

    def id(self):
        self.next_id += 1
        return self.next_id

    def new_wait_for_id(self):
        return "%s:%s" %( self.prefix, id(f) )

    def singleton_id(self):
        return "%s:%s" % (self.prefix, self.id())


    def clean_event(self, event):
        if 'async_def_futures' in event:
            for k in ['async_def_futures', 'async_def_result', 'reply_now', 'reply_error_now', 'wait_for', 'results']:
                if k in event:
                    del event[k]

    async def forward(self, event, override_keys):
        wait_for_id = cell.new_wait_for_id()
        event['wait_for'].append(wait_for_id)
        event = copy.copy(event)
        self.clean_event(event)
        event.update(override_keys)
        await cells.emit(event)

    def CellsBySelector(self, selector):
        """ select cells within cells """
        if (type(selector) == type({})):
              if  'id' in selector:
                  if selector['id'] in self.cells:
                      return [self.cells[selector['id']]]
                  else:
                      return []
              elif 'ids' in selector:
                  return [self.cells[id] for id in selector['ids'] if id in self.cells]
              elif 'listens_to' in selector:
                  l_name = 'l_%s' % selector.listens_to
                  return [cell for cell in self.cells.value() if hasattr(cell, l_name) and callable(getattr(cell, l_name))]
              else:
                  raise "unkown selector %s" % str(selector)
        elif (type(selector) == type('') and selector == 'all'):
              return self.cells.values()
        else:
              raise 'selector %s not implemented yet ' % str(selector)

    async def emit_selector(self, event):
        await self.emit(event, self.CellsBySelector(event.get('selector', 'all')))

    async def emit(self, event, py_cells):
        l_name = 'l_%s' % event['type']
        for cell in [cell for cell in py_cells if hasattr(cell, l_name)]:
            listener = getattr(cell, l_name)
            if callable(listener):
                # The listeners should return fast and offload heavy operations using async_def_futures and async_def_result
                await listener(event)

class Cell(object):
  """Docstring for Cell. """

  # TODO do I need this
  # def call_soon(*kargs, **kwargs):
  #     cell_collection.asyncio_loop.call_soon(*kargs, **kwargs)

  def __init__(self, **kwargs):
      id = kwargs.get('id', None)
      for k in kwargs.keys():
        setattr(self, k, kwargs[k])
      if not hasattr(self, 'id'):
        self.id = "%s:%d" % (cell_collection.prefix, cell_collection.id())
      cell_collection.cells[self.id] = self
      self.requests = {}

  def reply_event(event, reply_event):
    reply_event['type'] = 'reply'
    reply_event['selector'] = {'id': event['reply_to']}
    if 'request_id' in event:
      reply_event['request_id'] = event['request_id']
    return reply_event

  # def reply_coroutine(self, event, c, replies = 1):
  #     futures = [asyncio.Future() for x in range(1, replies)]
  #     for f in futures:
  #         wait_for_id = cells.cell_collection.prefix+cells.cell_collection.id()
  #         event['wait_for'].append(wait_for_id)
  #         def cb(r):
  #             #if event['reply_by'] == 'results':
  #                 #sults
  #           cells.emit(self.reply_event(event, {'result': r, 'wait_for_id': wait_for_id} ))
  #         f.add_done_callback(cb)
  #     # TODO do I need this
  #     cell_collection.asyncio_loop.call_soon(lambda: asyncio.ensure_future(c(*futures)))
  #     c(futures)

  def kill(self):
      del cell_collection.cells[self.id]
      cells.emit({'sender': self.id, 'type': 'killed'})

  # ASK IMPLEMENTATION
  def cancel_request(self, request_id):
      request = self.requests.pop(request_id, None)
      if request == None:
          return
      for id in request.waiting_for.keys():
        cells.emit({'type': 'cancel_request', 'request_id': request_id}, {'id': id})

  async def cancel_ask(self, event, request = {}):
      """ See viml.vim """
      for k in self.requests.keys():
        i = self.requests[k]
        if has_key(i,'type') and get(i, 'type') == request.type:
            self.cancel_request(k)
      self.ask(event, request)

  async def ask(self, event, request = None, results_only = True):
    results = []
    errors = []
    async for x in self.ask_iter(event, request):
            results.append(x)
    if results_only:
        return [x['result'] for x in results if 'result' in x]
    else:
        return results

  def __process_wait_for(self, request, wait_for_id):
      if wait_for_id in request['replies_to_be_waited_for']:
          yield from self.__process_event_waited_for(request, request['replies_to_be_waited_for'].pop(wait_for_id))
      else:
          request['waiting_for'][wait_for_id] = 1

  def __process_event_waited_for(self, request, event):
    if 'result' in event or 'error' in event:
        yield event
    if 'results' in event:
        yield from event['results']
    for wait_for_id in event.get('wait_for', []):
        yield from self.__process_wait_for(request, wait_for_id)

  async def ask_iter(self, event, request = None):
    try:
        if request is None:
            request = {}
        request_id = "%s-%s" % (cell_collection.prefix, cell_collection.id())
        event['request_id'] = request_id
        self.requests[request_id] = request
        event['reply_to'] = self.id

        request['event'] = event
        request['replies_to_be_waited_for'] = {}
        request['cancel'] = 0
        request['waiting_for'] = {}
        request['queue'] = asyncio.Queue(maxsize = 1) # contains list of results

        await emit(event)

        for r in event['results']:
            yield r

        for wait_for_id in event['wait_for']:
            for r in self.__process_wait_for(request, wait_for_id):
                yield r

        while len(request['waiting_for']) > 0:
            results = await request['queue'].get()
            for result in results:
                yield result


    except Exception as e:
        raise e

  async def l_reply(self, event):
      request_id = event['request_id']

      request = self.requests[request_id]

      if event['wait_for_id'] in request['waiting_for']:
          request['waiting_for'].pop(event['wait_for_id'])
          await request['queue'].put(list(self.__process_event_waited_for(request, event)))
      else:
          request['replies_to_be_waited_for'][event['wait_for_id']] = event

class CellPy(Cell):
    """ cell implementing basic api for the cell collection """

    async def l_cell_collections(self, event):
        event['reply_now'](self.id, {'prefix': cell_collection.prefix, 'details': 'default Python cell collection'})

    async def l_emit(self, event):
        await cell_collection.emit_selector(event['event'])

    async def l_cell_kill(self, event):
        for c in cell_collection.CellsBySelector(event['selector']):
            c.kill()

    async def l_cell_list(self, event):
        event['reply_now'](self.id, [x.id for x in  cell_collection.CellsBySelector(event.get('selector', 'all'))])

    async def l_cell_new_by_name(self, event):
        if event.get('network', cell_collection.prefix) != cell_collection.prefix:
            return
        module_and_class = event['name'].split('.')
        module, clazz = ['.'.join(module_and_class[0:-1]), module_and_class[-1]]
        try:
            i = __import__(module)
            for p in module_and_class[1:-1]:
                i = getattr(i, p)
            cell = getattr(i, clazz)(*event.get('args', []), **event.get('kargs', {}))
        except Exception as e:
            debug_str('importing from module %s class %s failed' % (module, clazz))
            raise e
        # TODO reply

# class CellPyEventToVim(Cell):
#     """ Events Python -> Vim
#         See cells#viml#vim8_VimEventToPy for Vim -> Python
#     """

#     def __init__(self):
#         super(CellPyEventToVim, self).__init__()

#     async def l_emit(self, event):
#         if event['event']['origin_network'] == cell_collection.prefix:
#             import vim
#             import cells.util
#             event_ = copy.copy(event['event'])
#             for k in ['results', 'wait_for']:
#                 if k in event_:
#                     event_[k] = []

#             cells.util.to_vim(event_)
#             event_ = vim.eval('cells#util#EmitReturn(g:to_vim)')

#             for k in ['results', 'wait_for']:
#                 if k in event_:
#                     event['event'][k] += event_[k]

## MAIN INTERFACE

async def emit(event):

  if 'reply_to' in event:
    event['wait_for'] = event.get('wait_for', [])
    event['results']  = event.get('results', [])
    # a coroutine can run immediately without waiting, then its fine to add the
    # result to 'results', otherwise the an async event must be used
    event['reply_by'] = 'result'

    wait_for_dict = {} # remember which ids should be waited for. If a result can be returned immediately because no await happens (?)
    def wait_for(wait_for_id):
        wait_for_dict[wait_for_id] = True

    async def task_done(sender, wait_for_id, result):
        result['wait_for_id'] = wait_for_id
        result['sender'] = sender
        r = Cell.reply_event(event, result)
        if event['reply_by'] == 'result':
            del wait_for_dict[wait_for_id]
            event['results'].append(r)
        else:
            await emit(r)

    async def async_def_futures(sender, num, async_def_fun, *args, **kwargs):
        """
            usage:
            async def async_def_futures(futures):
                futures[0].set_result({'result': 2})
                futures[0].set_result({'error': 'foo'})
            event["async_def_futures"](2, async_def_futures)
        """

        futures = [Future() for x in range(0, num)]
        for f in futures:
            wait_for_id = cell_collection.new_wait_for_id()
            wait_for(wait_for_id)

        kwargs['futures'] = futures

        async_def = async_def_fun(**args, **kwargs)

        def done_callback(task):
            wait_for_id = "%s:%s" % ( cells.cell_collection.prefix, id(task) )
            try:
                asyncio.Task(task_done(sender, wait_for_id, {'result': task.result()}))
            except Exception as e:
                asyncio.Task(task_done(sender, wait_for_id, {'error': traceback.format_exc()}))

        for f in futures:
            task_or_future.add_done_callback(done_callback)

        async def run_async_def():
            error = "unset future"
            try:
                r = await async_def()
            except Exception as e:
                error = traceback.format_exc()
                debug_str(error)

            # finish all futures always
            for f in futures:
                if not f.done():
                    f.set_result({'error': error})

        # maybe this causes immediate return ? TODO test it
        await asyncio.wait([run_async_def()], timeout = 0)

    async def async_def_result(sender, async_def):
        """ usage:
            async def async_def_result():
                return "result" # or throw exception
            event["async_def_result"](async_def_result) 
        """

        wait_for_id = "%s-%s" % (cell_collection.prefix, cell_collection.id())
        wait_for(wait_for_id)

        async def run_async_def():
            try:
                r = await async_def
                await task_done(sender, wait_for_id, {'result': r})
            except Exception as e:
                error = traceback.format_exc()
                debug_str(error)
                await task_done(sender, wait_for_id, {'error': error})
        # maybe this causes immediate return ? TODO test it
        await asyncio.wait([run_async_def()], timeout = 0)

    def reply_now(sender, r):
        event['results'].append(Cell.reply_event(event, {'result': r, 'sender': sender}))

    def reply_error_now(sender, e):
        event['results'].append(Cell.reply_event(event, {'error': e, 'sender': sender}))

    # allow event handlers to return replies by async functions
    # emit must return early to return wait_for
    event['async_def_futures'] = async_def_futures
    event['async_def_result']  = async_def_result
    event['reply_now'] = reply_now
    event['reply_error_now']  = reply_error_now

  if not 'origin_network' in event:
    event['origin_network'] = cell_collection.prefix

  await cell_collection.emit_selector({'type': 'emit', 'event': event})

  if 'reply_to' in event:
    event['reply_by'] = 'event'
    for wait_for_id in wait_for_dict.keys():
      event['wait_for'].append(wait_for_id)

async def kill(selector):
  await emit({'type': 'killcells', 'selector': selector})

async def log(lines):
  await emit({'type': 'log', 'lines': lines})

# def do_threadsafe(lambda_):
#     cell_collection.asyncio_loop.call_soon_threadsafe(lambda_)
