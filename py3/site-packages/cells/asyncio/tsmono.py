#!/usr/bin/env python
import json
import tempfile
print("SOURCI")
import cells.asyncio.error_line_parsers as elp
import traceback
import cells.asyncio as cells_a
import cells.util as util
import re
import os
import math
from glob import glob
import os.path
import asyncio
import tempfile
from os.path import basename, dirname
from cells.debug import debug_str
from cells.asyncio.jsonrpc import JsonRPC

# class TSS():
class Tsmono(cells_a.Cell):
    """ connects to tsserver and, tells which files to update and implements features such as completion """

    def __init__(self, *args, **kwargs):
        super(Tsmono, self).__init__(*args, **kwargs)
        self.tsmono_result

    async def __initial_errors_current_buf(self):
        cc = (await self.ask_editor_commands(commands = ['cursor_context']))[0][0]
        asyncio.Task(self.__errors({'for_filepaths': [cc['filepath']]}))

    def reset_errors(self):
        self.errors = {'syntaxDiag': [], 'semanticDiag': []}

    async def __completions(self, event):
        if (basename(event['filepath']) != "tsmono.json"):
            return []

        lsac = event['line_split_at_cursor']
        dirs = glob(dirname(dirname(event['filepath']))+'/*')
        match = re.search('[a-zA-Z-_]*$', lsac[0]) # TODO unicode chars!
        word_before_cursor   = "" if match == None else match.group(0)
        completions = util.match_by_type2([{'word': basename(x)+"\",", 'kind': 'Tsmono', 'info': x} for x in dirs], word_before_cursor)
        column = int(event['position'][2]) - len(word_before_cursor)
        return [{
            'column': column,
            'completions': completions
        }]

    async def l_completions(self, event):
        await event['async_def_result'](self.id, self.__completions(event['event']))


    async def l_editor_bufwritepost(self, event):
        if (basename(event['filepath']) != "tsmono.json"):
            return
        cmd = 'zsh -c ". ~/.zshrc; tsmono update --link-to-links --force 2>&1"'
        proc = await asyncio.create_subprocess_shell(
            cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE)

        stdout, stderr = await proc.communicate()
        self.tsmono_result = stdout.decode('utf8') + "\n" + stderr.decode('utf8')
        asyncio.Task(cells_a.emit({'type': 'quickfix_list_available', 'sender': self.id}))

    async def l_quickfix_list(self, event):
        event['reply_now'](self.id, {'truncated': False, 'list': [ {'text': x} for x in self.tsmono_result.split("\n")]})
