#!/usr/bin/env python
# turns error lines into quickfix like error lines
import re
from cells.debug import debug_str

class LineParserState():

    def __init__(self, lines):
        self.lines = lines
        self.index = 0
        self.result_list = []

    def eol(self):
        return self.index >= len(self.lines)

    def line(self, offset = 0):
        i = self.index + offset
        if i >= len(self.lines):
            return ""
        return self.lines[i]

    def append(self, r):
        self.result_list.append(r)


def to_vim(line_parsers, lines):
    lps = LineParserState(lines)

    while not lps.eol():
        index = lps.index
        for p in line_parsers:
            p(lps)
        if (index == lps.index):
            raise Exception('no parser consumed current line %s. To fix append line_parser_consume_line to your error_line_parser list' % lps.line())

    return lps.result_list

def line_parser_ruby_ignore_warning(lps):
    re_match_warning = re.compile('^([^:])*:([^:])*: warning: (.*)')

def line_parser_ruby_sample_text():
    """ for testing line_parser_ruby"""
    return [
            " NoMethodError: undefined method `url' for nil:NilClass",
            " 	from test-skyexpress-neues-formular.rb:43:in `<top (required)>'",
            " 	from (irb):9:in `load'",
            " 	from (irb):9",
            " 	from /nix/store/p0f76l8kmkg2aj2i421898iwzh1h4mik-ruby-2.3.5/bin/irb:11:in `<main>'"
            ]

re_from = re.compile('^[ \t]+from ([^:]*):([^:]*)(:in (.*))?')
rb_re_syntax_error = re.compile('^SyntaxError: ([^:]*):([^:]*)(:(.*))?')

def line_parser_ruby(lps):
    match = re_from.match(lps.line(+1))
    if (match):
        lps.append({'text': lps.line()})
        lps.index+=1
        while True:
            match = re_from.match(lps.line())
            if not match:
                break
            lps.index+=1
            lps.append({'filename': match.group(1), 'text': '', 'lnum': match.group(2), 'type' : 'E'})

    match = rb_re_syntax_error.match(lps.line())
    if (match):
        lps.index+=1
        lps.append({'filename': match.group(1), 'text': '', 'lnum': match.group(2), 'type' : 'E'})



re_tss_comp_types = re.compile('(.*Argument of type )(.*) (is not assignable to parameter of type) (.*)')
def tss_comp_types(s, list):
    match = re_tss_comp_types.match(s)
    if (match):
        for g in [1,3,2,4]:
                list.append({'text': match.group(g)})
        return True
    return False

re_tss_is_not_assignable = re.compile('Type (.*)( is not assignable to .* is missing in type )(.*)')
def tss_is_not_assignable(s, list):
    match = re_tss_is_not_assignable.match(s)
    if (match):
        for g in [1,2,3]:
            list.append({'text': match.group(g)})
        return True
    return False

# lps = LineParserState(["TS2345: Argument of type '{ 'data': CustomerData; 'form_errors': FormErrors; }' is not assignable to parameter of type '{ customer_data: CustomerData; form_errors: FormErrors; } & Lifecycle<{ customer_data: CustomerDa...'. "])
# print(str(to_vim([line_parser_webpack, line_parser_consume_line lps)))
def line_parser_webpack(lps):
    result_list = lps.result_list
    lines       = lps.lines
    re_empty_line = re.compile('^[ ]*$')
    re_tsl_line = re.compile('.*\[tsl\] ERROR in ([^(]*)\(([^,]*),([^,]*)\)')

    # TS2345: Argument of type '{ 'data': CustomerData; 'form_errors': FormErrors; }' is not assignable to parameter of type '{ customer_data: CustomerData; form_errors: FormErrors; } & Lifecycle<{ customer_data: CustomerDa...'. 

    line = lps.line()

    match = re_tsl_line.match(line)
    if (match):
        lps.index+=2
        message = lps.lines[lps.index-1]
        # everything on one line is often hard to read, so put message one line below
        lps.append({'filename': match.group(1), 'text': '', 'col': match.group(3), 'lnum': match.group(2), 'type' : 'E'})

        if tss_comp_types(message, lps.result_list):
            return
        elif tss_is_not_assignable(message, lps.result_list):
            return
        else:
            lps.append({'text': message})
        return

def line_parser_consume_line(lps):
    """ conume line, add as noisy text """
    if not lps.eol():
        lps.append({'text': lps.line()})
        lps.index+=1
