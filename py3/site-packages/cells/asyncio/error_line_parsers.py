#!/usr/bin/env python
# turns error lines into quickfix like error lines
import re
from cells.debug import debug_str

class LineParserState():

    def __init__(self, lines):
        self.lines = lines
        self.index = 0
        self.result_list = []

    def eol(self):
        return self.index >= len(self.lines)

    def line(self, offset = 0):
        i = self.index + offset
        if i >= len(self.lines):
            return ""
        return self.lines[i]

    def append(self, r):
        self.result_list.append(r)


def to_vim(line_parsers, lines):
    lps = LineParserState(lines)

    while not lps.eol():
        index = lps.index
        for p in line_parsers:
            p(lps)
        if (index == lps.index):
            raise Exception('no parser consumed current line %s. To fix append line_parser_consume_line to your error_line_parser list' % lps.line())

    return lps.result_list

def line_parser_ruby_ignore_warning(lps):
    re_match_warning = re.compile('^([^:])*:([^:])*: warning: (.*)')

def line_parser_ruby_sample_text():
    """ for testing line_parser_ruby"""
    return [
        " NoMethodError: undefined method `url' for nil:NilClass",
        " 	from test-skyexpress-neues-formular.rb:43:in `<top (required)>'",
        " 	from (irb):9:in `load'",
        " 	from (irb):9",
        " 	from /nix/store/p0f76l8kmkg2aj2i421898iwzh1h4mik-ruby-2.3.5/bin/irb:11:in `<main>'"
        ]

def line_parser_ruby(lps):
    re_from = re.compile('^ 	from ([^:]*):([^:]*)(:in (.*))?')
    match = re_from.match(lps.line(+1))
    if (match):
        lps.append({'text': lps.line()})
        lps.index+=1
        while True:
            match = re_from.match(lps.line())
            if not match:
                break
            lps.index+=1
            lps.append({'filename': match.group(1), 'text': '', 'lnum': match.group(2), 'type' : 'E'})



# lps = LineParserState(["TS2345: Argument of type '{ 'data': CustomerData; 'form_errors': FormErrors; }' is not assignable to parameter of type '{ customer_data: CustomerData; form_errors: FormErrors; } & Lifecycle<{ customer_data: CustomerDa...'. "])
# print(str(to_vim([line_parser_webpack, line_parser_consume_line lps)))
def line_parser_webpack(lps):
    result_list = lps.result_list
    lines       = lps.lines
    re_empty_line = re.compile('^[ ]*$')
    re_tsl_line = re.compile('.*\[tsl\] ERROR in ([^(]*)\(([^,]*),([^,]*)\)')

    # TS2345: Argument of type '{ 'data': CustomerData; 'form_errors': FormErrors; }' is not assignable to parameter of type '{ customer_data: CustomerData; form_errors: FormErrors; } & Lifecycle<{ customer_data: CustomerDa...'. 
    re_comp_types = re.compile('(.*Argument of type )(.*) (is not assignable to parameter of type) (.*)')

    line = lps.line()

    match = re_tsl_line.match(line)
    if (match):
        lps.index+=2
        message = lps.lines[lps.index-1]
        # everything on one line is often hard to read, so put message one line below
        lps.append({'filename': match.group(1), 'text': '', 'col': match.group(3), 'lnum': match.group(2), 'type' : 'E'})

        match = re_comp_types.match(message)
        if (match):
            for g in [1,3,2,4]:
                lps.append({'text': match.group(g)})
            return
        else:
            lps.append({'text': message})
        return

def line_parser_consume_line(lps):
    """ conume line, add as noisy text """
    if not lps.eol():
        lps.append({'text': lps.line()})
        lps.index+=1
