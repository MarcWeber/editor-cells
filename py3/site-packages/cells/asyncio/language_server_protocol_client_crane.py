#!/usr/bin/env python
import json
import glob

# TODO refactor using language_server_protocl_client.py's LanguageServerProtocolClient class
# 

# crane.js see https://github.com/HvyIndustries/crane/issues/359


# http://langserver.org/ support
# usage LanguageServerProtocolClient(port = "80")
# connect via stdio
# usage LanguageServerProtocolClient(cmd = "xx")

import glob
import traceback
import cells.asyncio as cells_a
import cells.util as util
import cells.asyncio.jsonrpc
import re
import os
import math
import glob
import os.path
import asyncio
from cells.debug import debug_str
import cells.asyncio.language_server_protocol_client as lsp


class LanguageServerProtocolClientCrane(lsp.LanguageServerProtocolClient):
    """provide completions based on files"""

    def __init__(self, *args, **kwargs):
        super(LanguageServerProtocolClientCrane, self).__init__(*args, **kwargs)

        self.php_files_globbed = set()
        self.maybe_unsafed_files = set()

    # no file:// uris !?? fix upstream
    def uri_from_cursor_context(self, cursor_context):
        return 'file://'+ cursor_context['filepath']

    def CursorContext_To_TextDocumentIdentifier(self, cursor_context):
        return {'uri': self.uri_from_cursor_context(cursor_context) }

    def CursorContext_To_Position(self, cursor_context):
        return {'line': int(cursor_context['position'][1]) - 1, 'character': int(cursor_context['position'][2]) - 1}

    def CursorContext_To_TextDocumentPositionParams(self, cursor_context):
        return {
                'textDocument': self.CursorContext_To_TextDocumentIdentifier(cursor_context),
                'position': self.CursorContext_To_Position(cursor_context)
        }

    async def buildFromFiles_call(self):
        rootDir = os.getcwd()
        php_files_globbed = glob.glob(rootDir+'/**/*.php', recursive = True)
        self.php_files_globbed = set(php_files_globbed)
        self.known_php_files = set(php_files_globbed + list(self.maybe_unsafed_files))
        await self.jsonrpc.call(
            method = "buildFromFiles",
            params = {
                'files': php_files_globbed,
                'craneRoot': rootDir,
                'projectPath': rootDir,
                'treePath': rootDir+'/crane-tree.cache',
                'enableCache': True,
                'rebuild': True
            }
        )
        self.file_state_tracking.reset()

    # duplicate
    async def tell_about_file(self, cursor_context):
        filepath = cursor_context['filepath']
        if not filepath in self.maybe_unsafed_files:
            self.maybe_unsafed_files.add(cursor_context['filepath'])
            await self.buildFromFiles_call()
        await self.file_state_tracking.open_and_update(cursor_context)

    # COMPLETION
    async def __completions(self, event):
        await self.tell_about_file(event['event'])

        lsac = event['event']['line_split_at_cursor']
        match = re.search('[a-zA-Z-_]*$', lsac[0]) # TODO unicode chars!
        word_before_cursor   = "" if match == None else match.group(0)
        word_before_cursor_1 = word_before_cursor

        debug_str("awaiting completion %s" % str(self.jsonrpc))
        r = await self.jsonrpc.call(method = "textDocument/completion", params = self.CursorContext_To_TextDocumentPositionParams(event['event']))
        debug_str("RESULT %s" % str(r))
        if r['result'] == None:
            completions = []
        else:
            # looks like some completions return [''], ignore them
            completions = [{'word': c['label'], 'w': 1.1, 'menu': c.get('detail', ''), 'kind' : c.get('kind', ''), 'info': c.get('documentation', '')} for c in r['result'] if isinstance(c['label'], str)]

        completions = util.match_by_type2(completions, word_before_cursor)
        column = int(event['event']['position'][2]) - len(word_before_cursor)

        return [{
            'column': column,
            'completions': completions
        }]

    async def l_completions(self, event):
        await event['async_def_result'](self.id, self.__completions(event))


    # DEFINITONS
    async def __definitions(self, event):
        await self.tell_about_file(event)
        r = await self.jsonrpc.call(method = "textDocument/definition", params = self.CursorContext_To_TextDocumentPositionParams(event))
        return [{'filepath': c['uri'][6:], 'line': c['range']['start']['line']+1, 'column': c['range']['start']['character']+1} for c in r['result']]

    async def l_definitions(self, event):
        await event['async_def_result'](self.id, self.__definitions(event))

# # USAGE
# async def __usages(self, event):
#     script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
#     definitions = script.usages()
#     return [{'filepath':  event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.doc, 'kind': 'JediCompletion'} for c in definitions]

# async def l_usages(self, event):
#     await event['async_def_result'](self.id, self.__usages(event))


#     # TYPE
#     async def __types(self, event):
#         script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
#         definitions = script.goto_assignments(follow_imports=True)
#         return [{'type': d.type ,'kind': 'JediCompletion'} for d in definitions]

#     async def l_types(self, event):
#         await event['async_def_result'](self.id, self.__types(event))

