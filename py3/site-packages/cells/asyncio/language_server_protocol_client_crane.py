#!/usr/bin/env python
import json
import glob

# merge with language_server_protocl_client.py  crane specific stuff is marked
# by CRANE, make something work first..

# http://langserver.org/ support
# usage LanguageServerProtocolClient(port = "80")
# connect via stdio
# usage LanguageServerProtocolClient(cmd = "xx")

import glob
import traceback
import cells.asyncio as cells_a
import cells.util as util
import cells.asyncio.jsonrpc
import re
import os
import math
import glob
import os.path
import asyncio
from cells.debug import debug_str
import cells.asyncio.language_server_protocol_client as lsp

# no file:// uris !?? fix upstream
def uri_from_cursor_context(cursor_context):
    return 'file://'+ cursor_context['filepath']

def CursorContext_To_TextDocumentIdentifier(cursor_context):
    return {'uri': uri_from_cursor_context(cursor_context) }

def CursorContext_To_Position(cursor_context):
    return {'line': int(cursor_context['position'][1]) - 1, 'character': int(cursor_context['position'][2]) - 1}

def CursorContext_To_TextDocumentPositionParams(cursor_context):
    return {
            'textDocument': CursorContext_To_TextDocumentIdentifier(cursor_context),
            'position': CursorContext_To_Position(cursor_context)
    }

class LanguageServerProtocolClientCrane(cells_a.Cell):
    """provide completions based on files"""

    def __init__(self, *args, **kwargs):
        super(LanguageServerProtocolClientCrane, self).__init__(*args, **kwargs)

        debug_str("LanguageServerProtocolClientCrane with kwargs %s" % str(kwargs))
        log_writer = None
        log_reader = None
        async def async_log_unexpected_message(s):
            # maybe this is too noisy
            debug_str(s)

        ic = lsp.init_call()
        del ic['params']['processId']
        self.jsonrpc = cells.asyncio.jsonrpc.JsonRPC(
            connection_properties = kwargs,
            init_calls = [ic],
            log_writer = log_writer,
            log_reader = log_reader,
            async_log_unexpected_message = async_log_unexpected_message
        )
        self.file_state_tracking = lsp.LanguageServerFileStateTracking(cell = self, jsonrpc = self.jsonrpc)

        self.php_files_globbed = set()
        self.maybe_unsafed_files = set()

    async def buildFromFiles_call(self):
        rootDir = os.getcwd()
        php_files_globbed = glob.glob(rootDir+'/**/*.php', recursive = True)
        self.php_files_globbed = set(php_files_globbed)
        self.known_php_files = set(php_files_globbed + list(self.maybe_unsafed_files))
        await self.jsonrpc.call(
            method = "buildFromFiles",
            params = {
                'files': php_files_globbed,
                'craneRoot': rootDir,
                'projectPath': rootDir,
                'treePath': rootDir+'/crane-tree.cache',
                'enableCache': True,
                'rebuild': True
            }
        )
        self.file_state_tracking.reset()

    async def tell_about_file(self, cursor_context):
        filepath = cursor_context['filepath']
        if not filepath in self.maybe_unsafed_files and not filepath in self.maybe_unsafed_files:
            self.maybe_unsafed_files.add(cursor_context['filepath'])
            debug_str("buildFromFiles_call")
            await self.buildFromFiles_call()
            debug_str("buildFromFiles_call done")
        await self.file_state_tracking.open_and_update(cursor_context)

    # COMPLETION
    async def __completions(self, event):
        await self.tell_about_file(event['event'])

        lsac = event['event']['line_split_at_cursor']
        match = re.search('[a-zA-Z-_]*$', lsac[0]) # TODO unicode chars!
        word_before_cursor   = "" if match == None else match.group(0)
        word_before_cursor_1 = word_before_cursor

        debug_str("awaiting completion %s" % str(self.jsonrpc))
        r = await self.jsonrpc.call(method = "textDocument/completion", params = CursorContext_To_TextDocumentPositionParams(event['event']))
        debug_str("RESULT %s" % str(r))
        if r['result'] == None:
            completions = []
        else:
            completions = [{'word': c['label'], 'w': 1.1, 'menu': c.get('detail', ''), 'kind' : c.get('kind', ''), 'info': c.get('documentation', '')} for c in r['result']]

        completions = util.match_by_type2(completions, word_before_cursor)
        column = int(event['event']['position'][2]) - len(word_before_cursor)

        return [{
            'column': column,
            'completions': completions
        }]

    async def l_completions(self, event):
        await event['async_def_result'](self.id, self.__completions(event))


    # DEFINITONS
    async def __definitions(self, event):
        await self.tell_about_file(event)
        r = await self.jsonrpc.call(method = "textDocument/definition", params = CursorContext_To_TextDocumentPositionParams(event))
        return [{'filepath': c['uri'][6:], 'line': c['range']['start']['line']+1, 'column': c['range']['start']['character']+1} for c in r['result']]

    async def l_definitions(self, event):
        await event['async_def_result'](self.id, self.__definitions(event))


    # # USAGE
    # async def __usages(self, event):
    #     script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
    #     definitions = script.usages()
    #     return [{'filepath':  event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.doc, 'kind': 'JediCompletion'} for c in definitions]

    # async def l_usages(self, event):
    #     await event['async_def_result'](self.id, self.__usages(event))


#     # TYPE
#     async def __types(self, event):
#         script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
#         definitions = script.goto_assignments(follow_imports=True)
#         return [{'type': d.type ,'kind': 'JediCompletion'} for d in definitions]

#     async def l_types(self, event):
#         await event['async_def_result'](self.id, self.__types(event))

