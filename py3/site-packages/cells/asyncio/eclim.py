#!/usr/bin/env python
import re
import cells.asyncio as cells_a
import cells.util
import json
import os.path
import os
import json
import io
from cells.debug import debug_str


# TODO: rewrite eval commands using Python ?
# TODO: add all features
# tested with PHP only

nailguns = {}

class Eclim(cells_a.Cell):
    """provide completions based on files"""

    def __init__(self, *args, **kwargs):
        super(Eclim, self).__init__(*args, **kwargs)
        debug_str("eclim id %s" % self.id)

    def instance(self):
        # {"home":"/home/marc/.eclipse/org.eclipse.platform_4.7.0_399169530_linux_gtk_x86_64/plugins/org.eclim_2.7.0/","workspace":"/home/marc/workspace","port":9091}
        return json.loads(open("%s/.eclim/.eclimd_instances" % os.environ['HOME'], "r").read())

    async def eclim_command(self, command):
        # TODO rewrite nailgun class using asyncio?
        port = self.instance()['port']
        if not nailguns.get(port):
            nailguns[port] = NailgunAsyncIO(port = port, keepAlive = True)
        (retcode, result) = await nailguns[port].send(command)
        return result
    
        # exit code is 48 ? for what reason? completion contents are there
     
        # if result == 0:
        #     return result
        # else:
        #     raise Exception("%s %s" %(retcode, result) )

    async def __prepare_buf_php(self, event):
        offset = event['event']['offset']
        # word length before cursor
        lsac = event['event']['line_split_at_cursor']

        # word before cursor, but keep one char to hint completion - TODO care about umlaute
        match = re.search('[a-zA-Z-_]*$', lsac[0]) # TODO unicode chars!
        word_before_cursor   = "" if match == None else match.group(0)
        word_before_cursor_1 = word_before_cursor
        commands = []
        commands.append({'eval': 'eclim#project#util#GetProjectRelativeFilePath()'})
        commands.append({'set_current_line': "%s" % lsac[0][0:len(lsac[0]) - len(word_before_cursor_1)] + ' ' * len(word_before_cursor_1) + lsac[1]})
        commands.append('write_current_buffer_silently')
        commands.append({'set_current_line': "%s" % lsac[0]+lsac[1]})
        r = await cells_a.Cell.ask_editor_commands(commands = commands)

        result = {
            'match': match,
            'lsac': lsac,
            'event_position': event['event']['position'],
            'project_path': r[0][0],
            'offset_minus': len(word_before_cursor_1.encode('utf-8')),
            'chars_minus' : len(word_before_cursor),
            'word_before_cursor' : word_before_cursor,
            'word_before_cursor_1' : word_before_cursor_1
        }
        debug_str("compl values %s" % str(result))
        return result

    async def __completions(self, event):
        # write buffer

        # now ask eclim
        filename, file_extension = os.path.splitext(event['event']['filepath'])
        column = None

        if file_extension == '.php':
            # if eclim#html#util#InCssBlock()
            #   return eclim#css#complete#CodeComplete(a:findstart, a:base)
            # endif
            # if !eclim#php#util#IsPhpCode(line('.'))
            #   return eclim#html#complete#CodeComplete(a:findstart, a:base)
            # endif
            x = await self.__prepare_buf_php(event)
            r = await self.eclim_command('vim -command php_complete -p "vv2" -f "%s" -o %s -e utf-8' % (x['project_path'], int(event['event']['offset'])-int(x['offset_minus'])))
            column = int(event['event']['position'][2]) - x['chars_minus']
            debug_str("column values %s" % column)
        else:
            raise Exception("TODO extension %s" % file_extension)

        #debug_str("got json %s " % r)
        completions = [{'w': x['relevance'], 'info': x['info'], 'menu': x['type'], 'word': x['completion'], 'kind': 'eclim' } for x in json.loads(r)]
        debug_str("completions:%s %s"%(str(completions), x['word_before_cursor']))
        completions = cells.util.match_by_type2(completions, x['word_before_cursor'])
        return [{ 'column': column, 'completions' : completions }]

        # {"completion":"$_COOKIE","menu":"$_COOKIE","info":"$_COOKIE","type":"","relevance":16000003,"javaDocURI":""}

    async def l_completions(self, event):
        await event['async_def_result'](self.id, self.__completions(event))


    # DEFINITONS
    async def __definitions(self, event):
        filename, file_extension = os.path.splitext(event['filepath'])

        if file_extension == '.php':
            #call '-editor vim -command php_search -n "vv2" -p uncaught_exception -x declarations'
            #result [0, '[{"filename":"/pr/www/vv2/lib/error-handling.php","offset":4095,"length":18,"line":129,"column":12,"message":"function uncaught_exception"}]']
            project_name = await cells_a.Cell.ask_editor_commands(commands = [{'eval':'eclim#project#util#GetCurrentProjectName()'}])
            project_name = project_name[0][0]
            result = await self.eclim_command("-editor vim -command php_search -n \"%s\" -p %s -x declarations" % (project_name, event['cword']))
            return [{'filepath': x['filename'], 'offset': x['offset']} for x in json.loads(result)]
        else:
            raise Exception("TODO extension %s" % file_extension)


    async def l_definitions(self, event):
        await event['async_def_result'](self.id, self.__definitions(event))

import asyncio.streams

class NailgunAsyncIO(object):

    def __init__(self, **kwargs):
        self.reader = None
        self.writer = None
        self.port = kwargs.get('port')
        self.keepAlive = int(kwargs.get('keepAlive', 0))
        self.reconnectCounter = 0

    async def write_str_utf8(s):
        await self.writer.write(s.encode('utf-8'))

    async def send(self, cmdline):
        """
        Sends a complete command to the nailgun server.  Handles connecting to the
        server if not currently connected.
        @param cmdline command, which is sent to server, for instance
          "-command ping".
        @return tuple consisting of:
          - retcode from server (0 for success, non-0 for failure)
          - string response from server
        """
        if self.reader == None:
            await self.reconnect()

        for arg in self.parseArgs(cmdline):
            await self.sendChunk("A", arg)

        if self.keepAlive:
            await self.sendChunk("K")

        await self.sendChunk("C", "org.eclim.command.Main")

        (retcode, result) = await self.processResponse()

        # if self.keepAlive and retcode:
        #   # force reconnect on error (may not be necessary)
        #   self.reconnect()
        return (retcode, result)

    async def reconnect(self):
        if self.writer != None:
            #self.reader.close()
            self.writer.close()
        self.reader, self.writer = await asyncio.open_connection(port = self.port)

    # async def close(self):

    def parseArgs(self, cmdline):
        # FIXME: doesn't handle escaping of spaces/quotes yet (may never need to)
        args = []
        arg = ''
        quote = ''
        for char in cmdline:
            if char == ' ' and not quote:
                if arg:
                    args.append(arg)
                    arg = ''
            elif char == '"' or char == "'":
                if quote and char == quote:
                    quote = ''
                elif not quote:
                    quote = char
                else:
                    arg += char
            else:
                arg += char

        if arg:
            args.append(arg)

        return args

    async def sendChunk(self, chunkType, text=''):
        """
        Sends a nailgun 'chunk' to the server.
        """
        btext = text.encode('utf-8')
        length = len(btext)
        # TODO there must be proper binary formatting tools
        self.writer.write((length).to_bytes(4, byteorder='big'))
        self.writer.write(chunkType.encode('utf-8'))
        self.writer.write(btext)

    async def processResponse(self):
        result = io.StringIO()
        exit = 0
        exitFlag = 1 # expecting 1 times exit chunk
        while exitFlag > 0:
            answer = await self.reader.read(5)
            lenPayload = int.from_bytes(answer[:4], byteorder='big')
            chunkType = chr(answer[4])
            if chunkType == "1":
                # STDOUT
                rec = await self.reader.read(lenPayload)
                result.write(rec.decode('utf-8'))
            elif chunkType == "2":
                # STDERR
                rec = await self.reader.read(lenPayload)
            elif chunkType == "X":
                exitFlag = exitFlag - 1
                r = await self.reader.read(2)
                exit = int.from_bytes(r, byteorder='big')
            else:
                print("error: unknown chunk type = %s\n" % chunkType)
                exitFlag = 0
                await self.reconnect()

        return [exit, result.getvalue()]

    def recvBlocked(self, lenPayload):
        """
        Receives until all data is read - necessary because usual recv sometimes
        returns with number of bytes read less then asked.
        """
        received = ""
        while (len(received) < lenPayload):
          received = received + self.socket.recv(lenPayload - len(received))
        return received
