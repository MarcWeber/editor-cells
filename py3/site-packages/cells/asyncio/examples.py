import cells.asyncio as cells_a
import cells.util as util
from cells.debug import debug_str
import re
import math
import glob
import os.path
import asyncio
import cells

class TagFile():

    def __init__(self, file):
        self.file = file
        self.cache = None

    async def reload(self):
        mtime = os.path.getmtime(self.file)
        if self.cache == None or self.cache['mtime'] < mtime:
            await self.__reload(mtime)

    async def __reload(self, mtime):
        lines = []
        for l in open(self.file, 'r').readlines():
            lines.append(l.split(' '))

        self.cache = {'mtime': mtime, 'lines': lines}

class CompletionTAGS (cells_a.Cell):
    """ Anton asked for ctags based completion """

    def __init__(self, *args, **kwargs):
        super(CompletionTAGS, self).__init__(*args, **kwargs)
        self.cache = {}

    async def tagfiles(self):
        return ['tags']

    async def __completions(self, event):
        debug_str(1)
        lsac = event['line_split_at_cursor']
        match = re.search('[a-zA-Z-_]*$', lsac[0]) # TODO unicode chars!
        word_before_cursor   = "" if match == None else match.group(0)
        word_before_cursor_1 = word_before_cursor

        debug_str(2)

        tag_files = await self.tagfiles()

        debug_str(3)
        f = cells.match.match_score_function(word_before_cursor)
        words = []
        for t in tag_files:
            debug_str(t)
            if os.path.isfile(t):
                if not t in self.cache:
                    self.cache[t] = TagFile(t)
                await self.cache[t].reload()
                debug_str("lines== %s" % t)
                debug_str(str(self.cache[t].cache['lines']))
                for l in self.cache[t].cache['lines']:
                    w = f(l[0])
                    if w > 0:
                        words.append({'word': l[0], 'w': w, 'description': '', 'count': 0, 'info': "CompletionTAGS %s" % str(l)})

        return [{ 'column': int(event['position'][2]) - len(word_before_cursor), 'completions' : words }]

    async def l_completions(self, event):
        await event['async_def_result'](self.id, self.__completions(event['event']))

class CompletionInEmails (cells_a.Cell):
    """ sample implemenattion illustrating how word completion within a buffer
         can be done showing words nearby the cursor rated higher
         implementing multiple match_types."""

    def __init__(self, *args, **kwargs):
        super(CompletionInEmails, self).__init__(*args, **kwargs)

    async def completions(self, oe):

        [ret] = await asyncio.gather(
            self.ask_editor_commands(commands = ['buffers', {'lines_of_buf_id':'%', 'to_line': 10000}])
        )

        files_open_in_vim    = ret[0][0]
        lines_current_buffer = ret[0][1]

        vim_filetype = files_open_in_vim['current']['vim_filetype']

        if vim_filetype != "mail" and not hasattr(self, 'all_filetypes'):
            return []
        else:
            words_ = re.split('[ \t\r\n.{}()<>\'"]', oe['event']['line_split_at_cursor'][0])
            word_before_cursor = words_[-1]

            # import email
            # msg = email.message_from_string("\n".join(lines_current_buffer))

            email_pattern = 'CHAR+@CHAR+'.replace('CHAR', '[-a-zA-Z.]')
            name_pattern = "(?:\"([^\"]+)\")"
            name_pattern2 = "(NAME(?:[ \t]+NAME)*)".replace("NAME", "[a-zA-Z.]+")
            regex_match_email = re.compile("\\b(%s)" % email_pattern)
            regex_match_email_name = re.compile('%s <%s>'  % (name_pattern, email_pattern) )
            regex_match_email_name2 = re.compile('%s <%s>' % (name_pattern2, email_pattern) )
            find_all = util.FindAll(word_before_cursor, regexes = [regex_match_email, regex_match_email_name, regex_match_email_name2])

            words = {}
            def add(word, certainity, info = "", kind = ""):
                if word == word_before_cursor or word == '':
                    return

                if word in words:
                    words[word]['count'] += 1
                    words[word]['w'] = max([words[word]['w'], certainity])
                else:
                    words[word] = {'word': word, 'w': certainity, 'description': word+' (py)', 'count': 0, 'info': info, 'kind': "CompletionBasedOnFiles %s" % kind}

            for line in lines_current_buffer:
                for word in find_all.all(line):
                    add(word, 10, kind = "CompletionInEmails")

            completions = util.match_by_type2(words.values(), word_before_cursor)
            return [{ 'column': int(oe['event']['position'][2]) - len(word_before_cursor), 'completions' : completions }]

    async def l_completions(self, event):

        await event['async_def_result'](self.id, self.completions(event))

class CompletionBasedOnFiles(cells_a.Cell):
    """provide completions based on files"""


    def __init__(self, *args, **kwargs):
        super(CompletionBasedOnFiles, self).__init__(*args, **kwargs)

    async def completions(self, oe):

        # TODO gather with timeout to catch problems
        [ret, project_files] = await asyncio.gather(
             self.ask_editor_commands(commands = ['buffers', {'lines_of_buf_id':'%', 'to_line': 10000}]),
          self.ask({'type': 'project_files'}),
        )
        files_open_in_vim    = ret[0][0]
        lines_current_buffer = ret[0][1]

        rest = set(sum(project_files, [])) - set(files_open_in_vim)
        words_ = re.split('[ \t\r\n.{}()<>\'"!]', oe['event']['line_split_at_cursor'][0])
        word_before_cursor = words_[-1]

        words = {}

        def add(word, certainity, info = "", kind = ""):
            if word == word_before_cursor or word == '':
                return

            if word in words:
                words[word]['count'] += 1
                words[word]['w'] = max([words[word]['w'], certainity])
            else:
                words[word] = {'word': word, 'w': certainity, 'description': word+' (py)', 'count': 0, 'info': info, 'kind': "CompletionBasedOnFiles %s" % kind}

        linenr = 1
        nearby_cursor_lines = 100

        match_str = util.match_regex_str_by_types(word_before_cursor, oe['event']['match_types'])
        re_match = re.compile('^'+match_str)

        # buffer_lines = lines_current_buffer[0]
        # buffer_line_count = len(buffer_lines)
        # for line in buffer_lines:
        #     for w in line.split(' '):
        #         if not re_match.match(w):
        #             continue
        #         line_diff = float(linenr) - float(oe['event']['position'][1])
        #         abs_line_diff = abs(line_diff)


        #         hint = ""
        #         if abs_line_diff > nearby_cursor_lines:
        #             certainity = 0.4 * (abs_line_diff / buffer_line_count)
        #             hint = "0.4"
        #         else:
        #             # words in lines nearby cursor are more important ..
        #             certainity = 1 + (1.0 - (abs_line_diff / nearby_cursor_lines))
        #             hint = certainity
        #             if linenr > int(oe['event']['position'][1]):
        #                 # lines below cursor are less important than above cursor
        #                 certainity = math.sqrt(certainity)
        #                 hint = "%s sqrt" % certainity
        #         add(w, 2 + certainity)
        #     linenr += 1

        find_all = util.CompletionWordsFromStr(word_before_cursor, ['camel_case_like', 'ignore_case'])
        re_last_upper_str = util.match_regex_str(word_before_cursor, 'last_upper')
        re_last_upper     = re.compile(re_last_upper_str) if re_last_upper_str != None else None

        for file in list(rest):
            if (os.path.isfile(file)):
                for word in find_all.all(open(file,'r').read()):
                    add(word, 10 if re_last_upper != None and re_last_upper.match(word) else 0.5)

        # get lines of 20 most recently used files in Vim from buffer
        bufids = files_open_in_vim['buffers_visited_order'][0:20]
        results = await self.ask_editor_commands(commands = [{'lines_of_buf_id': bufid} for  bufid in bufids])
        certainity = 1
        for (bufid, lines) in zip(bufids, results[0]):
            try:
                file_open_in_vim = files_open_in_vim['buffers'][bufid]
            except (IndexError, KeyError):
                file_open_in_vim = None
            last_line = None
            basename = None
            if not file_open_in_vim == None:
                basename = os.path.basename(file_open_in_vim['filepath'])
                last_line = int(file_open_in_vim['last_cursor_pos'][1]) if 'last_cursor_pos' in file_open_in_vim else None
            if last_line == None:
                last_line = -500
            for (line_0, line) in enumerate(lines):
                line_dist = (line_0+1) - last_line
                f_distance = 1 if line_dist == 0 else (0.99 / abs(line_dist)) / 5 + 0.8
                if line_dist > 0 and bufid == files_open_in_vim['current']['bufid']:
                    # lines below cursor are less likely to be a hit?
                    f_distance *= 0.9
                for word in find_all.all(line):
                    # words not nearby last cursor position or buffers having used earlier get less weight
                    add(word,
                            certainity * f_distance * (10 if re_last_upper != None and re_last_upper.match(word) else 1),
                            kind = "bufid %s - %s" % (bufid, basename)
                            )
            certainity *= 0.8
        completions = list(words.values()) # util.match_by_type(words.values(), word_before_cursor)

        # normalizing results, these completions provide high noise

        if len(completions) == 0:
            return []

        # for w in completions:
        #     w['w'] = w['w'] + math.atan(w['count'] / 10) # so result should should be somwhere between 1 and 2

        # maxv = max([x['w'] for x in completions])
        # for w in completions:
        #     w['w'] = w['w'] / maxv

        # completions.sort(key = lambda a: -a['w']) # so results should be less than 1
        # completions = completions[0:int(oe['event']['limit'])]

        return [{ 'column': int(oe['event']['position'][2]) - len(word_before_cursor), 'completions' : completions }]

    async def l_completions(self, event):
        """ sample implemenattion illustrating how word completion within a buffer
            can be done showing words nearby the cursor rated higher
            implementing multiple match_types."""

        await event['async_def_result'](self.id, self.completions(event))

class Completion(cells_a.Cell):
    """Docstring for CompletionBasedOnOpenBuffers. """

    async def l_completions(self, event):
        """ sample implemenattion illustrating how word completion within a buffer
            can be done showing words nearby the cursor rated higher
            implementing multiple match_types."""
        import vim

        words_ = re.split('[ \t\r\n.{}()<>\'"]', event['event']['line_split_at_cursor'][0])
        word_before_cursor = words_[-1]

        words = {}
        linenr = 1

        nearby_cursor_lines = 100.0

        for line in vim.current.buffer[:]:
            for w in line.split(' '):
                if w == word_before_cursor or w == '':
                    continue
                line_diff = linenr - int(event['event']['position'][1])
                if abs(line_diff) > nearby_cursor_lines:
                    certainity = 1
                else:
                    # words in lines nearby cursor are more important ..
                    certainity = 1+ (1.0 - abs(line_diff) / nearby_cursor_lines)
                    if linenr > int(event['event']['position'][1]):
                        # lines below cursor are less important than above cursor
                        certainity = math.sqrt(certainity)
                words[w] = {'word': w, 'w': certainity, 'description': w+' (py)'}
            linenr += 1

        completions = util.match_by_type2(words.values(), word_before_cursor)
        self.reply_now(event, [{ 'column': int(event['event']['position'][2]) - len(word_before_cursor), 'completions' : completions }])


class Mappings(cells_a.Cell):
    """Tell the editor about some mappings"""

    def __init__(self, *args, **kwargs):
        super(Mappnigs, self).__init__(*args, **kwargs)
        asyncio.Task(cells_a.emit({'type': 'mappings_changed', 'sender': self.id}))

    async def l_mappigns(self, event):
        mappings = []
        mappings.append({'scope': 'global',                 'mode': 'normal', 'lhs': '<f5>', 'emit_event': {'type': 'do_echo', 'text': 'scope=g f5 was hit, from pyhton'}})
        mappings.append({'scope': 'bufnr:4',                'mode': 'normal', 'lhs': '<f6>', 'emit_event': {'type': 'do_echo', 'text': 'scope=g f6 was hit, from pyhton'}})
        mappings.append({'scope': 'filepath_regex:\.js$',   'mode': 'normal', 'lhs': '<f7>', 'emit_event': {'type': 'do_echo', 'text': 'scope=g f7 was hit, from pyhton'}})
        self.reply_now(event, mappings)

    async def l_do_echo(self, event):
        cells_a.Log(event.text)

class Signs(cells_a.Cell):

    def __init__(self):
        super(Signs, self).__init__()
        cells_a.emit({'type': 'signs_changed', 'sender': self.id})

    async def l_signs(self, event):
        event['reply_now'](self.id, [{'bufnr': 1, 'name': 'test', 'category' : 'test', 'definition': 'text=-', 'signs': [{'line': 2, 'comment': 'comment about sign - on line 2, from python' }]}])

class Quickfix(cells_a.Cell):

    def __init__(self):
        super(Quickfix, self).__init__()
        Task(cells_a.emit({'type': 'quickfix_list_available', 'sender': self.id}))

    async def l_quickfix_list(self, event):
        event['reply_now'](self.id, {'truncated': False, 'list': [{'bufnr': 1, 'text': 'error', 'col': 10, 'lnum': 5, 'type' : 'E'}]})


