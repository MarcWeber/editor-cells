#!/usr/bin/env python
import re
import json
import traceback
import asyncio
import os
import copy

from cells.debug import debug_str


class chan_json_rpc():

    def write_msg(self, msg):
        b = json.dumps(msg, separators=(',', ':')).encode('utf-8')
        self.writer.write(("Content-Length: %s\r\n\r\n" % len(b)).encode('utf-8'), log = False)
        self.writer.write(b)
        debug_str("message written")

    async def receive_msg(self):
        headers = {}
        while True:
            l = await self.reader.readline(log = False)
            l_decoded = l.decode('utf-8')
            m = re.match("^([^:]*): (.*)$", l_decoded)
            if m:
                headers[m.group(1)] = m.group(2)
            elif re.match("^[\r\n]*\r$", l_decoded):
                break
            else:
                raise Exception("unexpected line: %s" % l_decoded)

        debug_str("got headers %s" % str(headers))

        len_ = int(headers['Content-Length'])
        c = await self.reader.readexactly(len_)
        c = c.decode('utf-8')

        return json.loads(c)

class chan_cmd_stdio(chan_json_rpc):

    async def create(**kwargs):
        self = chan_cmd_stdio()
        create = asyncio.create_subprocess_shell(kwargs['cmd'], stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE)
        process = await create

        self.reader, self.writer = sprocess.stdout, process.stdin
        if self.writer == None:
            raise Exception('Something failed')

        # catch TODO stderr and log?
        return self

    def tidy(self):
        self.writer.close()

class chan_cmd_port(chan_json_rpc):

    async def create(**kwargs):
        self = self.chan_cmd_port()
        self.reader, self.writer = await asyncio.open_connection(port = kwargs['port'])
        return self

    def tidy(self):
        self.writer.close()

class chan_cmd_node_ipc():

    async def create(**kwargs):
        loop = asyncio.get_event_loop()

        self = chan_cmd_node_ipc()
        import socket
        import fcntl

        def no_clo_exec(fd):
            flags = fcntl.fcntl(fd, fcntl.F_GETFD)
            flags &= ~fcntl.FD_CLOEXEC
            return fcntl.fcntl(fd, fcntl.F_SETFD, flags)

        s1, s2 = socket.socketpair()
        no_clo_exec(s2.fileno())

        pid = os.fork()
        if pid == 0:
            # child
            env = copy.copy(os.environ)
            env['NODE_CHANNEL_FD'] = str(s2.fileno())
            path = "/run/current-system/sw/bin/node"
            path = "./child-emulation"
            args = [path, 'child.js']
            f = open("/tmp/execve-lo", "w")
            os.dup2(1, f.fileno())
            os.dup2(2, f.fileno())
            pid = os.execve(kwargs['cmd'][0], kwargs['cmd'], env)
            # this is likely to crash due to memory allocations don't know, see python code
            debug_str("execve %s failed" % str(kwargs['cmd']) )

        else:
            # parent
            self.pid = pid

            # is this stable? code gathered from reading open_connection code
            waiter = loop.create_future()
            reader = asyncio.StreamReader(loop=loop) # limit=
            protocol = asyncio.StreamReaderProtocol(reader, loop=loop)
            transport = loop._make_socket_transport(s1, protocol, waiter)
            writer = asyncio.StreamWriter(transport, protocol, reader, loop)
            self.reader, self.writer = reader, writer

        return self

    def write_msg(self, msg):
        self.writer.write(("%s\n" % json.dumps(msg)).encode('utf-8'))

    async def receive_msg(self):
        return json.loads(await self.reader.readline())

    def tidy(self):
        os.kill(self.pid, 9)
        self.process.kill()
        self.writer.close()

class JsonRPC():
    """ connects to a JSONRPC server """

    def __init__(self, connection_properties, init_calls = [], wait_for_server_messages = True, async_log_unexpected_message = None, log_writer = None, log_reader = None):
        self.id = 1

        self.log_reader = log_reader
        self.log_writer = log_writer

        self.waiting = {}
        self.connection_properties = connection_properties
        self.reconnect_counter = 0
        # server connection stuff
        self.tasks_to_kill_on_reconnect = {}
        self.chan = None
        self.wait_for_server_messages = wait_for_server_messages
        self.init_calls = init_calls
        self.async_log_unexpected_message = async_log_unexpected_message

    async def reconnect(self):
        self.reconnect_counter += 1
        self.l1_empty_count = 0
        if self.reconnect_counter > 10:
            raise Exception('Something went wrong ? - more than 10 attempts to start server')

        if self.chan != None:
            self.chan.tidy()
            for k in self.tasks_to_kill_on_reconnect:
                self.tasks_to_kill_on_reconnect.pop(k).kill()

        if 'port' in self.connection_properties:
            self.chan = await chan_cmd_port.create(**self.connection_properties)

        elif 'cmd' in self.connection_properties:

            if 'node_ipc' in self.connection_properties:
                self.chan = await chan_cmd_node_ipc.create(**self.connection_properties)
            else:
                self.chan = await chan_cmd_stdio.create(**self.connection_properties)

        else:
            raise Exception("bad connection params: %s, eg port or cmd is missing " % self.cp)

        results = []
        for i in self.init_calls:
            results.append(await self.call(**i))
        return results

    async def send(self, **kwargs):
        """ same as call but no id and don't wait for a result"""
        if self.chan == None:
            await self.reconnect()

        f = asyncio.Future()
        self.waiting[id] = f
        if len(self.waiting) > 2000:
            raise Exception("something went wrong -  too many failures")
        if not 'receive_replies' in self.tasks_to_kill_on_reconnect:
            self.tasks_to_kill_on_reconnect['receive_replies'] = asyncio.Task(self.receive_replies())
        kwargs['jsonrpc'] = "2.0"
        self.chan.write_msg(kwargs)

    async def call(self, **kwargs):
        if self.chan == None:
            debug_str("(re)connecting")
            await self.reconnect()
            debug_str("done")

        id = self.id
        self.id += 1

        f = asyncio.Future()
        self.waiting[id] = f
        if len(self.waiting) > 2000:
            raise Exception("something went wrong -  too many failures")
        if not 'receive_replies' in self.tasks_to_kill_on_reconnect:
            self.tasks_to_kill_on_reconnect['receive_replies'] = asyncio.Task(self.receive_replies())
        kwargs['id'] = id
        kwargs['jsonrpc'] = "2.0"
        if self.log_writer != None:
            self.log_writer(kwargs)
        self.chan.write_msg(kwargs)
        return await f

    async def process_incoming_reply(self):
        try:
            r = await self.chan.receive_msg()
            if self.log_reader != None:
                self.log_reader(r)

            if 'method' in r and r['method'] == '$/partialResult':
                # {"jsonrpc":"2.0","method":"$/partialResult","params":{"id":3,"patch":[{"op":"add","path":"/isIncomplete","value":false}]}}
                # {"jsonrpc":"2.0","method":"$/partialResult","params":{"id":3,"patch":[{"op":"add","path":"/items/-","value":{"label":"NaN","sortText":"0","documentation":"","detail":"const NaN: number"}}]}}
                return # ignoring for now

            if 'id' in r and r['id'] in self.waiting:
                self.waiting.pop(r['id']).set_result(r)
            else:
                # showMessage case or such?
                # await cells_a.emit({'type': 'editor_commands', 'commands': [{'show_message': "unhandled server protocol server message: %s " % str(r)}]})
                if self.async_log_unexpected_message != None:
                    await self.async_log_unexpected_message(str(r))

        except Exception as e:

            if self.l1_empty_count > 5:
                # Maybe there is a better way to check
                raise Exception('Probably server died')
            self.l1_empty_count += 1

            error = traceback.format_exc()
            debug_str(error)
            raise e

    async def receive_replies(self):
        debug_str("receive_replies STARTING")
        while self.wait_for_server_messages or len(self.waiting) > 0:
            await self.process_incoming_reply()
        # keep receiving
        # self.tasks_to_kill_on_reconnect.pop('receive_replies')


# example usage
#  future_workspace_files_procssed = asyncio.Future()
#  
#  async def async_log_unexpected_message(s):
#      st = str(s)
#      if re.search('Workspace files have processed', st):
#          print('future fine')
#          future_workspace_files_procssed.set_result("done")
#      print(st)
#  
#  def log_reader(s):
#      print("got %s" % str(s))
#  
#  def log_writer(s):
#      print("sent %s" % str(s))
#  
#  jsonrpc = JsonRPC(connection_properties = {'cmd': 'tee /tmp/in |node --inspect-brk --inspect /pr/tmp/crane2/client/server/server.js --stdio |tee /tmp/out', 'id': 'PHPCompletion'}, init_calls = [ init_call(), buildFromFiles_call() ], async_log_unexpected_message = async_log_unexpected_message, log_writer = log_writer, log_reader = log_reader)
#  
#  loop = asyncio.get_event_loop()
#  
#  async def test():
#      print("awaiting reconnecting")
#      await jsonrpc.reconnect()
#      print("awaiting workspace files processed")
#      await future_workspace_files_procssed
#      print(str(await jsonrpc.call(method = "textDocument/didOpen", params = {"textDocument":{"uri":file,"languageId":"php","version":1,"text": "\n".join(file_contents)}})))
#      # {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/marc/x.php","version":2},"contentChanges":[{ "text": "\n".join(file_contents)}]}}
#      print("sending completion event")
#      r = await jsonrpc.call(
#              method = "textDocument/completion",
#              params = {
#                  'textDocument': {'uri': file },
#                  'position': {'line': 2, 'character': 2}
#              })
#      print(str(r))
#  
#  
#  asyncio.Task(test())
#  loop.run_forever()
#  loop.run_until_complete(test())
