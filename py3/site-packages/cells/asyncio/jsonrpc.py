#!/usr/bin/env python
import re
import json
import traceback
import asyncio
import os

from cells.debug import debug_str


class JsonRPC():
    """ connects to a JSONRPC server """

    def __init__(self, connection_properties, init_calls = [], wait_for_server_messages = True, async_log_unexpected_message = None, log_writer = None, log_reader = None):
        self.id = 1
        self.waiting = {}
        self.cp = connection_properties
        self.reconnect_counter = 0
        # server connection stuff
        self.tasks_to_kill_on_reconnect = {}
        self.writer = None
        self.reader = None
        self.wait_for_server_messages = wait_for_server_messages
        self.init_calls = init_calls
        self.log_writer = log_writer
        self.log_reader = log_reader
        self.async_log_unexpected_message = async_log_unexpected_message

    async def reconnect(self):
        self.reconnect_counter += 1
        if self.reconnect_counter > 10:
            raise Exception('Something went wrong ? - more than 10 attempts to start server')

        if self.writer != None:
            #self.reader.close()
            self.writer.close()
            for k in self.tasks_to_kill_on_reconnect:
                self.tasks_to_kill_on_reconnect.pop(k).kill()

        if 'port' in self.cp:
            self.reader, self.writer = await asyncio.open_connection(port = self.cp['port'])

        elif 'cmd' in self.cp:
            create = asyncio.create_subprocess_shell(self.cp['cmd'], stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE)
            process = await create
            self.reader, self.writer = process.stdout, process.stdin
            if self.writer == None:
                raise Exception('Something failed')

            async def stderr_to_debug_s():
                debug_str(await process.stdout.readline())

            #self.tasks_to_kill_on_reconnect['stderr_to_debug_s'] = asyncio.Task(stderr_to_debug_s())

        else:
            raise Exception("bad connection params: %s, eg port or cmd is missing " % self.cp)
        writer = self.writer

        results = []
        for i in self.init_calls:
            results.append(await self.call(**i))
        return results

    def write(self, x, log = True):
        if self.log_writer != None and log:
            self.log_writer(x)
        self.writer.write(x)

    async def readline(self, log = True):
        r = await self.reader.readline()
        if self.log_reader != None and log:
            self.log_reader(r)
        return r

    async def readexactly(self, x, log = True):
        r = await self.reader.readexactly(x)
        if self.log_reader != None:
            self.log_reader(r)
        return r

    async def send(self, **kwargs):
        """ same as call but no id and don't wait for a result"""
        if self.writer == None:
            await self.reconnect()

        f = asyncio.Future()
        self.waiting[id] = f
        if len(self.waiting) > 2000:
            raise Exception("something went wrong -  too many failures")
        if not 'receive_replies' in self.tasks_to_kill_on_reconnect:
            self.tasks_to_kill_on_reconnect['receive_replies'] = asyncio.Task(self.receive_replies())
        kwargs['jsonrpc'] = "2.0"
        b = json.dumps(kwargs, separators=(',', ':')).encode('utf-8')
        self.write(("Content-Length: %s\r\n\r\n" % len(b)).encode('utf-8'), log = False)
        self.write(b)

    async def call(self, **kwargs):
        if self.writer == None:
            debug_str("(re)connecting")
            await self.reconnect()
            debug_str("done")

        id = self.id
        self.id += 1

        f = asyncio.Future()
        self.waiting[id] = f
        if len(self.waiting) > 2000:
            raise Exception("something went wrong -  too many failures")
        if not 'receive_replies' in self.tasks_to_kill_on_reconnect:
            self.tasks_to_kill_on_reconnect['receive_replies'] = asyncio.Task(self.receive_replies())
        kwargs['id'] = id
        kwargs['jsonrpc'] = "2.0"
        b = json.dumps(kwargs, separators=(',', ':')).encode('utf-8')
        self.write(("Content-Length: %s\r\n\r\n" % len(b)).encode('utf-8'), log = False)
        self.write(b)
        debug_str("message written")
        return await f

    async def process_incoming_reply(self):
        try:
            l1 = await self.readline(log = False)
            l2 = await self.readline(log = False) # separator line
            m = re.match("Content-Length: ([0-9]+)", l1.decode('utf-8'))
            if m:
                len = int(m.group(1))
                c = await self.readexactly(len)
                c = c.decode('utf-8')
                # Example of partial result (ignoring for now)

                r = json.loads(c)

                if 'method' in r and r['method'] == '$/partialResult':
                    # {"jsonrpc":"2.0","method":"$/partialResult","params":{"id":3,"patch":[{"op":"add","path":"/isIncomplete","value":false}]}}
                    # {"jsonrpc":"2.0","method":"$/partialResult","params":{"id":3,"patch":[{"op":"add","path":"/items/-","value":{"label":"NaN","sortText":"0","documentation":"","detail":"const NaN: number"}}]}}
                    return # ignoring for now

                if 'id' in r and r['id'] in self.waiting:
                    self.waiting.pop(r['id']).set_result(r)
                else:
                    # showMessage case or such?
                    # await cells_a.emit({'type': 'editor_commands', 'commands': [{'show_message': "unhandled server protocol server message: %s " % str(r)}]})
                    if self.async_log_unexpected_message != None:
                        await self.async_log_unexpected_message(str(r))
            else:
                raise Exception("Expected Content-Length-Line, but got %s " % l1)
        except Exception as e:
            error = traceback.format_exc()
            debug_str(error)

    async def receive_replies(self):
        debug_str("receive_replies STARTING")
        while self.wait_for_server_messages or len(self.waiting) > 0:
            await self.process_incoming_reply()
        # keep receiving
        # self.tasks_to_kill_on_reconnect.pop('receive_replies')


# example usage
#  future_workspace_files_procssed = asyncio.Future()
#  
#  async def async_log_unexpected_message(s):
#      st = str(s)
#      if re.search('Workspace files have processed', st):
#          print('future fine')
#          future_workspace_files_procssed.set_result("done")
#      print(st)
#  
#  def log_reader(s):
#      print("got %s" % str(s))
#  
#  def log_writer(s):
#      print("sent %s" % str(s))
#  
#  jsonrpc = JsonRPC(connection_properties = {'cmd': 'tee /tmp/in |node --inspect-brk --inspect /pr/tmp/crane2/client/server/server.js --stdio |tee /tmp/out', 'id': 'PHPCompletion'}, init_calls = [ init_call(), buildFromFiles_call() ], async_log_unexpected_message = async_log_unexpected_message, log_writer = log_writer, log_reader = log_reader)
#  
#  loop = asyncio.get_event_loop()
#  
#  async def test():
#      print("awaiting reconnecting")
#      await jsonrpc.reconnect()
#      print("awaiting workspace files processed")
#      await future_workspace_files_procssed
#      print(str(await jsonrpc.call(method = "textDocument/didOpen", params = {"textDocument":{"uri":file,"languageId":"php","version":1,"text": "\n".join(file_contents)}})))
#      # {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/marc/x.php","version":2},"contentChanges":[{ "text": "\n".join(file_contents)}]}}
#      print("sending completion event")
#      r = await jsonrpc.call(
#              method = "textDocument/completion",
#              params = {
#                  'textDocument': {'uri': file },
#                  'position': {'line': 2, 'character': 2}
#              })
#      print(str(r))
#  
#  
#  asyncio.Task(test())
#  loop.run_forever()
#  loop.run_until_complete(test())
