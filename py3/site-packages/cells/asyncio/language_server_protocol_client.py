#!/usr/bin/env python
import json

# http://langserver.org/ support


# usage LanguageServerProtocolClient(port = "80")
# connect via stdio
# usage LanguageServerProtocolClient(cmd = "xx")

import traceback
import cells.asyncio as cells_a
import cells.util as util
import re
import os
import math
import glob
import os.path
import asyncio
from cells.debug import debug_str

def init_call():
    workspaceCapabiilties = {
        # 'applyEdit' : False,
        #'workspaceEdit' : { documentChanges :True/False }
        #'didChangeConfiguration' : { documentChanges :True/False }
        #'didChangeWatchedFiles' : { documentChanges :True/False }
        #'symbol'         : { dynamicRegistration :True/False }
        #'executeCommand' : { dynamicRegistration :True/False }
    }

    textDocumentClientCapabilities = {
        'synchronization' : {
            # dynamicRegistration: True /False
            # willSave: True/False
            # willSaveWaitUntil:True/False
            # didSave:True/False
        },
        'completion': {
            # dynamicRegistration: True /False
            #completionItem?: { snippetSupport?: boolean; }
        },
        'hover': {
            # dynamicRegistration: True /False
        },
        'signatureHelp': {
            # dynamicRegistration: True /False
        },
        'references': {
            # dynamicRegistration: True /False
        },
        'documentHighlight': {
            # dynamicRegistration: True /False
        },
        'documentSymbol': {
            # dynamicRegistration: True /False
        },
        'formatting': {
            # dynamicRegistration: True /False
        },
        'rangeFormatting': {
            # dynamicRegistration: True /False
        },
        'onTypeFormatting': {
            # dynamicRegistration: True /False
        },
        'definition': {
            # dynamicRegistration: True /False
        },
        'codeAction': {
            # dynamicRegistration: True /False
        },
        'codeLense': {
            # dynamicRegistration: True /False
        },
        'documentLink': {
            # dynamicRegistration: True /False
        },
        'rename': {
            # dynamicRegistration: True /False
        },
    }

    debug_str("initializing client server protocol server ")

    rootDir = os.getcwd()

    return {
        'method': "initialize",
        'params': {
            'processId': os.getpid(),
            'rootUri': rootDir,
            #initializationOptions
            'capabilities': {
                'workspace': workspaceCapabiilties,
                'textDocument': textDocumentClientCapabilities,
                # 'experimental': {},
            }
        }
    }

def uri_from_cursor_context(cursor_context):
    return 'file://'+ cursor_context['filepath']

def CursorContext_To_TextDocumentIdentifier(cursor_context):
    return {'uri': uri_from_cursor_context(cursor_context) }

def CursorContext_To_Position(cursor_context):
    return {'line': int(cursor_context['position'][1]) - 1, 'character': cursor_context['position'][2]}

def CursorContext_To_TextDocumentPositionParams(cursor_context):
    return {
            'textDocument': CursorContext_To_TextDocumentIdentifier(cursor_context),
            'position': CursorContext_To_Position(cursor_context)
    }

class LanguageServerFileStateTracking():

    def __init__(self, *args, cell = None, jsonrpc = None):
        self.cell = cell
        self.jsonrpc = jsonrpc
        self.reset()



    async def open_and_update(self, cursor_context):
        uri = uri_from_cursor_context(cursor_context)
        results = await self.cell.ask_editor_commands(commands = [{'lines_of_buf_id': '%'}])
        lines = results[0][0]
        if not uri in self.submitted:
            self.submitted[uri] = {'version': 1, 'lines': lines}
            await self.jsonrpc.send(method = "textDocument/didOpen", params = {"textDocument":{"uri": uri,"languageId":"php","version":1, "text": "\n".join(lines)}})
        else:
            submitted = self.submitted[uri]
            submitted['version'] += 1
            # TODO send differential updates for speed reasons if files are large
            await self.jsonrpc.send(method = "textDocument/didChange", params = {"textDocument":{"uri": uri,"version":submitted['version']}, "contentChanges": [{'text': "\n".join(lines)}]})

    def reset(self):
        self.submitted = {}

class JsonRPC():

    def __init__(self, connection_properties, wait_for_server_messages = True):
        self.id = 1
        self.waiting = {}
        self.cp = connection_properties

        self.reconnect_counter = 0

        # server connection stuff
        self.tasks_to_kill_on_reconnect = {}
        self.writer = None
        self.reader = None
        self.wait_for_server_messages = wait_for_server_messages

    async def reconnect(self):
        self.reconnect_counter += 1
        if self.reconnect_counter > 10:
            raise Exception('Something went wrong ? - more than 10 attempts to start server')

        if self.writer != None:
            #self.reader.close()
            self.writer.close()
            for k in self.tasks_to_kill_on_reconnect:
                self.tasks_to_kill_on_reconnect.pop(k).kill()

        if 'port' in self.cp:
            self.reader, self.writer = await asyncio.open_connection(port = self.cp['port'])

        elif 'cmd' in self.cp:
            create = asyncio.create_subprocess_shell(self.cp['cmd'], stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE)
            process = await create
            self.reader, self.writer = process.stdout, process.stdin
            if self.writer == None:
                raise Exception('Something failed')

            async def stderr_to_debug_s():
                debug_str(await process.stdout.readline())

            #self.tasks_to_kill_on_reconnect['stderr_to_debug_s'] = asyncio.Task(stderr_to_debug_s())

        else:
            raise Exception("bad connection params: %s, eg port or cmd is missing " % self.cp)

        self.capabilities = await self.init()

    async def call(self, **kwargs):
        debug_str("calling with %s" % str(kwargs))
        debug_str("B\n")
        if self.writer == None:
            await self.reconnect()

        debug_str("A\n")
        id = self.id
        self.id += 1

        f = asyncio.Future()
        self.waiting[id] = f
        if len(self.waiting) > 2000:
            raise Exception("something went wrong -  too many failures")
        if not 'receive_replies' in self.tasks_to_kill_on_reconnect:
            self.tasks_to_kill_on_reconnect['receive_replies'] = asyncio.Task(self.receive_replies())
        kwargs['id'] = id
        kwargs['jsonrpc'] = "2.0"
        b = json.dumps(kwargs, separators=(',', ':')).encode('utf-8')
        debug_str("Content-Length: %s\r\n\r\n" % len(b))
        debug_str(json.dumps(kwargs, separators=(',', ':')))
        self.writer.write(("Content-Length: %s\r\n\r\n" % len(b)).encode('utf-8'))
        self.writer.write(b)
        return await f


    async def process_incoming_reply(self):
        try:
            # debug_str("waiting for incoming line")
            l1 = await self.reader.readline()
            l2 = await self.reader.readline() # separator line
            # debug_str("got content-length line l1 %s" % l1)
            # debug_str("got line l2 %s" % l2)
            m = re.match("Content-Length: ([0-9]+)", l1.decode('utf-8'))
            if m:
                len = int(m.group(1))
                # debug_str("len is %s " % len)
                c = await self.reader.readexactly(len)
                c = c.decode('utf-8')

                # debug_str("got content %s" % c)
                # Example of partial result (ignoring for now)

                r = json.loads(c)

                if 'method' in r and r['method'] == '$/partialResult':
                    # {"jsonrpc":"2.0","method":"$/partialResult","params":{"id":3,"patch":[{"op":"add","path":"/isIncomplete","value":false}]}}
                    # {"jsonrpc":"2.0","method":"$/partialResult","params":{"id":3,"patch":[{"op":"add","path":"/items/-","value":{"label":"NaN","sortText":"0","documentation":"","detail":"const NaN: number"}}]}}
                    return # ignoring for now

                debug_str("got content as json %s KEYS %s" % (str(r), str(r.keys())))
                if 'id' in r and r['id'] in self.waiting:
                    self.waiting.pop(r['id']).set_result(r)
                else:
                    # showMessage case or such?
                    debug_str("got unexpected message %s" % r)
                    await cells_a.emit({'type': 'editor_commands', 'commands': [{'show_message': "unhandled server protocol server message: %s " % str(r)}]})
            else:
                raise Exception("Expected Content-Length-Line, but got %s " % l1)
        except Exception as e:
            error = traceback.format_exc()
            debug_str(error)

    async def receive_replies(self):
        debug_str("receive_replies STARTING")
        # while True:
        #     x = await self.reader.readexactly(20)
        #     debug_str("receive_replies snippet %s " % str(x))

        while self.wait_for_server_messages or len(self.waiting) > 0:
            await self.process_incoming_reply()

        # keep receiving
        # self.tasks_to_kill_on_reconnect.pop('receive_replies')

    async def init(self):
        workspaceCapabiilties = {
            # 'applyEdit' : False,
            #'workspaceEdit' : { documentChanges :True/False }
            #'didChangeConfiguration' : { documentChanges :True/False }
            #'didChangeWatchedFiles' : { documentChanges :True/False }
            #'symbol'         : { dynamicRegistration :True/False }
            #'executeCommand' : { dynamicRegistration :True/False }
        }

        textDocumentClientCapabilities = {
            'synchronization' : {
                # dynamicRegistration: True /False
                # willSave: True/False
                # willSaveWaitUntil:True/False
                # didSave:True/False
            },
            'completion': {
                # dynamicRegistration: True /False
                #completionItem?: { snippetSupport?: boolean; }
            },
            'hover': {
                # dynamicRegistration: True /False
            },
            'signatureHelp': {
                # dynamicRegistration: True /False
            },
            'references': {
                # dynamicRegistration: True /False
            },
            'documentHighlight': {
                # dynamicRegistration: True /False
            },
            'documentSymbol': {
                # dynamicRegistration: True /False
            },
            'formatting': {
                # dynamicRegistration: True /False
            },
            'rangeFormatting': {
                # dynamicRegistration: True /False
            },
            'onTypeFormatting': {
                # dynamicRegistration: True /False
            },
            'definition': {
                # dynamicRegistration: True /False
            },
            'codeAction': {
                # dynamicRegistration: True /False
            },
            'codeLense': {
                # dynamicRegistration: True /False
            },
            'documentLink': {
                # dynamicRegistration: True /False
            },
            'rename': {
                # dynamicRegistration: True /False
            },
            'rename': {
                # dynamicRegistration: True /False
            },
        }

        debug_str("initializing client server protocol server ")
        r = await self.call(
            method = "initialize",
            params = {
                'processId': os.getpid(),
                'rootUri': os.getcwd(),
                #initializationOptions
                'capabilities': {
                    'workspace': workspaceCapabiilties,
                    'textDocument': textDocumentClientCapabilities,
                    # 'experimental': {},
                }
            }
        )

        debug_str("reply of initialize is %s" % str(r))

        if 'retry' in r:
            debug_str("retrying after initiate reply %s" % c)
            self.reconnect()
            return

        if 'unknownProtocolVersion' in r:
            raise Exception("protocol version cannot be handled by server %s" % str(r))

        return r.get('capabilities', None)
        # export namespace TextDocumentSyncKind {
        # 	/**
        # 	 * Documents should not be synced at all.
        # 	 */
        # 	export const None = 0;
        
        # 	/**
        # 	 * Documents are synced by always sending the full content
        # 	 * of the document.
        # 	 */
        # 	export const Full = 1;
        
        # 	/**
        # 	 * Documents are synced by sending the full content on open.
        # 	 * After that only incremental updates to the document are
        # 	 * send.
        # 	 */
        # 	export const Incremental = 2;
        # }
        
        # /**
        #  * Completion options.
        #  */
        # export interface CompletionOptions {
        # 	/**
        # 	 * The server provides support to resolve additional
        # 	 * information for a completion item.
        # 	 */
        # 	resolveProvider?: boolean;
        
        # 	/**
        # 	 * The characters that trigger completion automatically.
        # 	 */
        # 	triggerCharacters?: string[];
        # }
        # /**
        #  * Signature help options.
        #  */
        # export interface SignatureHelpOptions {
        # 	/**
        # 	 * The characters that trigger signature help
        # 	 * automatically.
        # 	 */
        # 	triggerCharacters?: string[];
        # }
        
        # /**
        #  * Code Lens options.
        #  */
        # export interface CodeLensOptions {
        # 	/**
        # 	 * Code lens has a resolve provider as well.
        # 	 */
        # 	resolveProvider?: boolean;
        # }
        
        # /**
        #  * Format document on type options
        #  */
        # export interface DocumentOnTypeFormattingOptions {
        # 	/**
        # 	 * A character on which formatting should be triggered, like `}`.
        # 	 */
        # 	firstTriggerCharacter: string;
        
        # 	/**
        # 	 * More trigger characters.
        # 	 */
        # 	moreTriggerCharacter?: string[];
        # }
        
        # /**
        #  * Document link options
        #  */
        # export interface DocumentLinkOptions {
        # 	/**
        # 	 * Document links have a resolve provider as well.
        # 	 */
        # 	resolveProvider?: boolean;
        # }
        
        # /**
        #  * Execute command options.
        #  */
        # export interface ExecuteCommandOptions {
        # 	/**
        # 	 * The commands to be executed on the server
        # 	 */
        # 	commands: string[]
        # }
        
        # /**
        #  * Save options.
        #  */
        # export interface SaveOptions {
        # 	/**
        # 	 * The client is supposed to include the content on save.
        # 	 */
        # 	includeText?: boolean;
        # }
        
        # export interface TextDocumentSyncOptions {
        # 	/**
        # 	 * Open and close notifications are sent to the server.
        # 	 */
        # 	openClose?: boolean;
        # 	/**
        # 	 * Change notificatins are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
        # 	 * and TextDocumentSyncKindIncremental.
        # 	 */
        # 	change?: number;
        # 	/**
        # 	 * Will save notifications are sent to the server.
        # 	 */
        # 	willSave?: boolean;
        # 	/**
        # 	 * Will save wait until requests are sent to the server.
        # 	 */
        # 	willSaveWaitUntil?: boolean;
        # 	/**
        # 	 * Save notifications are sent to the server.
        # 	 */
        # 	save?: SaveOptions;
        # }
        
        # interface ServerCapabilities {
        # 	/**
        # 	 * Defines how text documents are synced. Is either a detailed structure defining each notification or
        # 	 * for backwards compatibility the TextDocumentSyncKind number.
        # 	 */
        # 	textDocumentSync?: TextDocumentSyncOptions | number;
        # 	/**
        # 	 * The server provides hover support.
        # 	 */
        # 	hoverProvider?: boolean;
        # 	/**
        # 	 * The server provides completion support.
        # 	 */
        # 	completionProvider?: CompletionOptions;
        # 	/**
        # 	 * The server provides signature help support.
        # 	 */
        # 	signatureHelpProvider?: SignatureHelpOptions;
        # 	/**
        # 	 * The server provides goto definition support.
        # 	 */
        # 	definitionProvider?: boolean;
        # 	/**
        # 	 * The server provides find references support.
        # 	 */
        # 	referencesProvider?: boolean;
        # 	/**
        # 	 * The server provides document highlight support.
        # 	 */
        # 	documentHighlightProvider?: boolean;
        # 	/**
        # 	 * The server provides document symbol support.
        # 	 */
        # 	documentSymbolProvider?: boolean;
        # 	/**
        # 	 * The server provides workspace symbol support.
        # 	 */
        # 	workspaceSymbolProvider?: boolean;
        # 	/**
        # 	 * The server provides code actions.
        # 	 */
        # 	codeActionProvider?: boolean;
        # 	/**
        # 	 * The server provides code lens.
        # 	 */
        # 	codeLensProvider?: CodeLensOptions;
        # 	/**
        # 	 * The server provides document formatting.
        # 	 */
        # 	documentFormattingProvider?: boolean;
        # 	/**
        # 	 * The server provides document range formatting.
        # 	 */
        # 	documentRangeFormattingProvider?: boolean;
        # 	/**
        # 	 * The server provides document formatting on typing.
        # 	 */
        # 	documentOnTypeFormattingProvider?: DocumentOnTypeFormattingOptions;
        # 	/**
        # 	 * The server provides rename support.
        # 	 */
        # 	renameProvider?: boolean;
        # 	/**
        # 	 * The server provides document link support.
        # 	 */
        # 	documentLinkProvider?: DocumentLinkOptions;
        # 	/**
        # 	 * The server provides execute command support.
        # 	 */
        # 	executeCommandProvider?: ExecuteCommandOptions;
        # 	/**
        # 	 * Experimental server capabilities.
        # 	 */
        # 	experimental?: any;
        # }



class LanguageServerProtocolClient(cells_a.Cell):
    """provide completions based on files"""

    def __init__(self, *args, **kwargs):
        super(LanguageServerProtocolClient, self).__init__(*args, **kwargs)
        debug_str("LanguageServerProtocolClient with kwargs %s" % str(kwargs))
        self.json_rcp = JsonRPC(connection_properties = kwargs)

    async def CursorContext_To_TextDocumentIdentifier(self, cursor_context):
        return {'uri': 'file://'+ cursor_context['filepath'] }

    async def CursorContext_To_Position(self, cursor_context):
        return {'line': cursor_context['position'][1], 'character': cursor_context['position'][2]}

    async def CursorContext_To_TextDocumentPositionParams(self, cursor_context):
        return {
                'textDocument': await self.CursorContext_To_TextDocumentIdentifier(cursor_context),
                'position': await self.CursorContext_To_Position(cursor_context)
        }

    # COMPLETION
    async def __completions(self, event):
        # await self.send_buf_updates(event['bufid'])

        lsac = event['event']['line_split_at_cursor']
        match = re.search('[a-zA-Z-_]*$', lsac[0]) # TODO unicode chars!
        word_before_cursor   = "" if match == None else match.group(0)
        word_before_cursor_1 = word_before_cursor

        r = await self.json_rcp.call(method = "textDocument/completion", params = await self.CursorContext_To_TextDocumentPositionParams(event['event']))
        debug_str("RESULT %s" % str(r))
        completions = [{'word': c['label'], 'w': 1.1, 'menu': c.get('detail', ''), 'kind' : c.get('kind', ''), 'info': c.get('documentation', '')} for c in r['result']['items']]

        completions = util.match_by_type2(completions, word_before_cursor)
        column = int(event['event']['position'][2]) - len(word_before_cursor)

        return [{
            'column': column + 1,
            'completions': completions
        }]

    async def l_completions(self, event):
        await event['async_def_result'](self.id, self.__completions(event))


    # DEFINITONS
    async def __definitions(self, event):

        r = await self.json_rcp.call(method = "textDocument/definition", params = [await self.CursorContext_To_TextDocumentPositionParams(event) ])
        script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
        definitions = script.goto_assignments(follow_imports=True)
        return [{'filepath': event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.doc, 'kind': 'JediCompletion'} for c in definitions]

    async def l_definitions(self, event):
        await event['async_def_result'](self.id, self.__definitions(event))


    # # USAGE
    # async def __usages(self, event):
    #     script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
    #     definitions = script.usages()
    #     return [{'filepath':  event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.doc, 'kind': 'JediCompletion'} for c in definitions]

    # async def l_usages(self, event):
    #     await event['async_def_result'](self.id, self.__usages(event))


#     # TYPE
#     async def __types(self, event):
#         script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
#         definitions = script.goto_assignments(follow_imports=True)
#         return [{'type': d.type ,'kind': 'JediCompletion'} for d in definitions]

#     async def l_types(self, event):
#         await event['async_def_result'](self.id, self.__types(event))

