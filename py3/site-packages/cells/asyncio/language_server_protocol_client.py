#!/usr/bin/env python
import json

# http://langserver.org/ support


# usage LanguageServerProtocolClient(port = "80")
# connect via stdio
# usage LanguageServerProtocolClient(cmd = "xx")

import traceback
import cells.asyncio as cells_a
import cells.util as util
from cells.util import none_to_s
import re
import os
import math
import glob
import os.path
import asyncio
from cells.debug import debug_str
import cells.asyncio.jsonrpc

def init_call():
    workspaceCapabiilties = {
        # 'applyEdit' : False,
        #'workspaceEdit' : { documentChanges :True/False }
        #'didChangeConfiguration' : { documentChanges :True/False }
        #'didChangeWatchedFiles' : { documentChanges :True/False }
        #'symbol'         : { dynamicRegistration :True/False }
        #'executeCommand' : { dynamicRegistration :True/False }
    }

    textDocumentClientCapabilities = {
        'synchronization' : {
            # dynamicRegistration: True /False
            # willSave: True/False
            # willSaveWaitUntil:True/False
            # didSave:True/False
        },
        'completion': {
            # dynamicRegistration: True /False
            #completionItem?: { snippetSupport?: boolean; }
        },
        'hover': {
            # dynamicRegistration: True /False
        },
        'signatureHelp': {
            # dynamicRegistration: True /False
        },
        'references': {
            # dynamicRegistration: True /False
        },
        'documentHighlight': {
            # dynamicRegistration: True /False
        },
        'documentSymbol': {
            # dynamicRegistration: True /False
        },
        'formatting': {
            # dynamicRegistration: True /False
        },
        'rangeFormatting': {
            # dynamicRegistration: True /False
        },
        'onTypeFormatting': {
            # dynamicRegistration: True /False
        },
        'definition': {
            # dynamicRegistration: True /False
        },
        'codeAction': {
            # dynamicRegistration: True /False
        },
        'codeLense': {
            # dynamicRegistration: True /False
        },
        'documentLink': {
            # dynamicRegistration: True /False
        },
        'rename': {
            # dynamicRegistration: True /False
        },
    }

    rootDir = os.getcwd()

    return {
        'method': "initialize",
        'params': {
            'processId': str(os.getpid()), # github:felixfbecker:php-language-server expects a string
            'rootUri': rootDir,
            #initializationOptions
            'capabilities': {
                'workspace': workspaceCapabiilties,
                'textDocument': textDocumentClientCapabilities,
                # 'experimental': {},
            }
        }
    }


class LanguageServerFileStateTracking():

    def __init__(self, *args, cell = None, jsonrpc = None):
        self.cell = cell
        self.jsonrpc = jsonrpc
        self.reset()

    def range(self, lines):
        text = "\n".join(lines)
        return {'range': {'start': {'line': 0, 'character': 0}, 'end': {'line': len(lines), 'character': len(lines[-1]) }}, 'text': text, 'rangeLength': len(text)}

    async def open_and_update(self, cursor_context):
        uri = self.cell.uri_from_cursor_context(cursor_context)
        results = await self.cell.ask_editor_commands(commands = [{'lines_of_buf_id': '%'}])
        lines = results[0][0]
        if not uri in self.submitted:
            debug_str("didOpen")
            submitted = self.submitted[uri] = {'version': 1, 'lines': lines}
            await self.jsonrpc.send(method = "textDocument/didOpen", params = {"textDocument":{"uri": uri,"languageId":"php","version":1, "text": "\n".join(lines)}})
            submitted['range'] = self.range(lines)
        else:
            debug_str("didChange")
            submitted = self.submitted[uri]
            submitted['version'] += 1
            # TODO send differential updates for speed reasons if files are large
            # range should be optional but, vscode-intelephense for instance requires it
            old_range = submitted['range']
            new_range = self.range(lines)
            await self.jsonrpc.send(method = "textDocument/didChange", params = {"textDocument":{"uri": uri,"version":submitted['version']}, "contentChanges": [{'text': new_range['text'], 'range': new_range['range'], 'rangeLength' : old_range['rangeLength']}]})
            submitted['range'] = new_range

    def reset(self):
        self.submitted = {}

class LanguageServerProtocolClient(cells_a.Cell):
    """provide completions based on files"""

    # maybe make them instance members of LanguageServerProtocolClient
    # so that only parst such as uri_from_cursor_context can be overwritten
    def uri_from_cursor_context(self, cursor_context):
        return 'file://'+ cursor_context['filepath']

    def CursorContext_To_TextDocumentIdentifier(self, cursor_context):
        return {'uri': self.uri_from_cursor_context(cursor_context) }

    def CursorContext_To_Position(self, cursor_context):
        # lines character from 0 for vscode-intelephense
        return {'line': int(cursor_context['position'][1])-1, 'character': int(cursor_context['position'][2])-1}

    def CursorContext_To_TextDocumentPositionParams(self, cursor_context):
        return {
                'textDocument': self.CursorContext_To_TextDocumentIdentifier(cursor_context),
                'position': self.CursorContext_To_Position(cursor_context)
        }

    def __init__(self, *args, **kwargs):
        super(LanguageServerProtocolClient, self).__init__(*args, **kwargs)
        debug_str("LanguageServerProtocolClient with kwargs %s" % str(kwargs))

        debug_str("LanguageServerProtocolClientCrane with kwargs %s" % str(kwargs))
        # log_writer = None
        def log_writer(s):
            debug_str(s)
        log_reader = None

        ic = init_call()
        del ic['params']['processId']
        self.jsonrpc = cells.asyncio.jsonrpc.JsonRPC(
            connection_properties = kwargs,
            init_calls = [ic],
            log_writer = log_writer,
            log_reader = log_reader
        )
        self.file_state_tracking = LanguageServerFileStateTracking(cell = self, jsonrpc = self.jsonrpc)

    # duplicate
    async def tell_about_file(self, cursor_context):
        filepath = cursor_context['filepath']
        await self.file_state_tracking.open_and_update(cursor_context)

    # COMPLETION
    async def __completions(self, event):
        await self.tell_about_file(event)
        # await self.send_buf_updates(event['bufid'])

        lsac = event['line_split_at_cursor']
        match = re.search('[a-zA-Z-_]*$', lsac[0]) # TODO unicode chars!
        word_before_cursor   = "" if match == None else match.group(0)
        word_before_cursor_1 = word_before_cursor

        r = await self.jsonrpc.call(method = "textDocument/completion", params = self.CursorContext_To_TextDocumentPositionParams(event))
        debug_str("RESULT %s" % str(r))
        completions = [{'word': none_to_s(c['label']), 'w': 1.1, 'menu': none_to_s(c.get('detail')), 'kind' : none_to_s(c.get('kind')), 'info': none_to_s(c.get('documentation'))} for c in r['result']['items']]

        completions = util.match_by_type2(completions, word_before_cursor)
        column = int(event['position'][2]) - len(word_before_cursor)

        return [{
            'column': column,
            'completions': completions
        }]

    async def l_completions(self, event):
        await self.tell_about_file(event['event'])
        await event['async_def_result'](self.id, self.__completions(event['event']))


    # DEFINITONS
    async def __definitions(self, event):
        await self.tell_about_file(event)
        r = await self.jsonrpc.call(method = "textDocument/definition", params = self.CursorContext_To_TextDocumentPositionParams(event))
        debug_str(str(r))
        return [{'filepath': c['uri'][6:], 'line': c['range']['start']['line']+1, 'column': c['range']['start']['character']+1} for c in r['result']]

    async def l_definitions(self, event):
        await event['async_def_result'](self.id, self.__definitions(event))

    # # USAGE
    # async def __usages(self, event):
    #     script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
    #     definitions = script.usages()
    #     return [{'filepath':  event['filepath'] if c.module_path is None else c.module_path, 'line': c.line, 'column': 1+c.column, 'title': c.name, 'text': c.doc, 'kind': 'JediCompletion'} for c in definitions]

    # async def l_usages(self, event):
    #     await event['async_def_result'](self.id, self.__usages(event))

#     # TYPE
#     async def __types(self, event):
#         script = await self.__script(event, line = int(event['position'][1]), column = int(event['position'][2])-1)
#         definitions = script.goto_assignments(follow_imports=True)
#         return [{'type': d.type ,'kind': 'JediCompletion'} for d in definitions]

#     async def l_types(self, event):
#         await event['async_def_result'](self.id, self.__types(event))

