#!/usr/bin/env python
import json
import unittest
from cells.util import merge_dicts_cow
import re

class TestUtils(unittest.TestCase):

    def test_CompletionWordsFromStr(self):
        cwfs = cells.util.CompletionWordsFromStr('abc', ['prefix', 'camel_case_like', 'ignore_case'])
        s1 = 'abc aee_bee_cee ABC'

        expected_words = s1.split(' ')
        self.assertEqual(cwfs.all(s1), expected_words)

        # zoomb should not be matched
        self.assertEqual(cwfs.all(s1+" zoomb"), expected_words)

    def test_match_regex_str_by_types(self):
        def test(type, word, to_be_matched): 
            s = cells.util.match_regex_str_by_types(word, [type])
            re_ = re.compile('^'+s)
            for m in to_be_matched:
                self.assertTrue(re_.match(m) != None)

        test('last_upper', 'aZ', to_be_matched = ['auoz'])
        test('prefix', 'aZ', to_be_matched = ['aZoetnh'])
        test('camel_case_like', 'abc', to_be_matched = ['ab_boo_clown'])


class TestPy3AsyncIO(unittest.TestCase):

    def testExternalAsyncIOTestScript(self):
        other_network = {'origin_network': 'other'}
        dicts = []
        dicts.append({"cell-collection-name":"py3test","receiving-cell-id":"dummy"})
        dicts.append({"set-loop-debug": True})
        # files to complete from (this file)
        dicts.append(merge_dicts_cow(other_network, {'type': 'cell_new_by_name', 'name': 'cells.asyncio.mock.ProjectCell', 'args': [], 'kwargs': {'project_files': [os.path.abspath(__file__)], 'id': 'ProjectCell'}}))
        dicts.append(merge_dicts_cow(other_network, {'type': 'cell_new_by_name', 'name': 'cells.asyncio.mock.Editor', 'args': [], 'kwargs': {'id': 'Editor'}}))
        # completion cell
        dicts.append(merge_dicts_cow(other_network, {'type': 'cell_new_by_name', 'name': 'cells.asyncio.examples.CompletionBasedOnFiles', 'args': [], 'kwargs': {'id': 'CompletionBasedOnFiles'}}))
        # completion request
        dicts.append({"reply_to": "external-cell", "request_id": "request_id_1", "type":"completions","event":{"limit":10,"line_split_at_cursor":["im","port json"],"type":"completions","position":[0,1,2,0],"match_types":["prefix"]},"selector":"all"})

        from subprocess import Popen, PIPE
        stdin_text = "\n".join([json.dumps(x) for x in dicts])+"\n"

        process = Popen(["python3", "-Wdefault", "bin/py3cellcollection.py", '--wait', '10', '--controllernotreplying'], stdin = PIPE, stdout = PIPE, stderr = PIPE)
        process.stdin.write(stdin_text.encode('utf-8'))
        (output, err) = process.communicate()
        print('output ', output)
        print('err ', err)
        stdout_lines = output.decode('utf-8').split("\n")
        for l in stdout_lines:
            print("line ", l)
        exit_code = process.wait()
        print("exit_code", exit_code)
        completion_reply = json.loads(stdout_lines[-2])
        self.assertEqual(completion_reply['request_id'], "request_id_1")
        print(str(completion_reply))
