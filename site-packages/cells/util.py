import re
import cells

def match_regex_str(word, type):
    anychar = '[a-zA-Z0-9_-]'
    if type == 'camel_case_like':
        return CamelCaseLikeMatching(word)
    if type == 'ignore_case':
        return '(?i)'+word+anychar+'*'
    if type == 'last_upper':
        return  CamelCaseLikeMatching(word[0:-1])+word[-1].lower()+'\\b' if re.match('.*[A-Z]$', word) else None
    if type == 'prefix':
        return  word
    if type == 'ycm_like':
        return ''.join([c+anychar+'*' for c in word])
    raise Exception('unkown match_regex_str type '+type)

def match_regex_str_by_types(word, types):
    regexes = [ y for y in [match_regex_str(word, t) for t in types] if y != None]
    return'(?:'+ '|'.join(regexes)+')'

class CompletionWordsFromStr(object):
    """try to find sensible completions based on word
    """

    def __init__(self, word, types):
        super(CompletionWordsFromStr, self).__init__()
        self.re = re.compile('\\b('+ match_regex_str_by_types(word, types) +')')

    def all(self, s):
        return self.re.findall(s)


def match_by_type(list, word, match_types):
    regexes = []
    filtered = []

    if 'prefix' in match_types:
        regexes.append([re.compile('^'+word), 1])
    if 'prefix_ignore_case' in match_types:
        regexes.append([re.compile('^\c'+word), 1])
    if 'ycm' in match_types:
        # order of chars .., match case, then without match
        regexes.append([re.compile('^\c'+word), 1])
        regexes.append([re.compile('^\c'+word), 1])
    if len(word) <= 5 and 'camel_case_like' in match_types:
        regexes.append([re.compile("^"+CamelCaseLikeMatching(word)), 1])
    if len(regexes) == 0:
        cells.Log('no known match types found')
        # resort to prefix matching
        regexes.append([re.compile('^'+word), 1])

    for l in list:
        if not 'certainity' in l:
          l['certainity'] = 1
        c = 0
        for r in regexes:
            if r[0].match(l['word']):
                if r[1] > c:
                    c = r[1]
        if c > 0:
            filtered.append(l)

    return filtered


def CamelCaseLikeMatching(expr):
    result = ''
    if (len(expr) > 5):
      return 'noMatchDoh'

    # no unicode support - shit
    re_upper = re.compile("[A-Z]")
    re_lower = re.compile('[a-z]')

    for c in expr:
        if re_upper.match(c):
            result += c+'[A-Z]*[a-z_]*'
        elif re_lower.match(c):
            result += c+'[A-Za-z_]*'
        else:
            result += c
    return result

def call_vim(fun_str, args_array):
    to_vim([fun_str, args_array])
    import vim
    return vim.eval('cells#util#Call(g:to_vim[0], g:to_vim[1])')
    vim.Function(fun_str)(*args_array)

    # vim.command('call add(g:calls, ["%s", %s])' % (fun_str, str(args_array)))

def to_vim(x):
    import vim
    vim.Function('cells#util#ToVim')(x)

def eval(cmd):
    import vim
    import json
    return json.loads(vim.eval('cells#json#Encode(%s)'))


def emit_return(event):
    try:
        cells.py.cell_collection.emit_selector(event)
        return event
    except Exception as e:
        import traceback
        print(traceback.format_exc())
        raise e
