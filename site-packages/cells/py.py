# Python implementation
import copy
import cells
import asyncio

if not 'cells' in locals():
    cells = {}

class CellCollection:
    """Events will be sent to the cells contained in this collection"""

    def __init__(self, prefix):
        """@todo: to be defined1. """
        self.prefix = prefix
        self.cells = {}
        self.next_id = 0
        self.asyncio_loop = asyncio.get_event_loop()

        # not threadsafe !
        self.queue_events_in  = asyncio.Queue()
        self.queue_events_out = asyncio.Queue()

    def id(self):
        self.next_id += 1
        return self.next_id

    def CellsBySelector(self, selector):
        """ select cells within cells """
        if (type(selector) == type({})):
              if  'id' in selector:
                  if selector['id'] in self.cells:
                      return [self.cells[selector['id']]]
                  else:
                      return []
              elif 'ids' in selector:
                  return [self.cells[id] for id in selector['ids'] if id in self.cells]
              elif 'listens_to' in selector:
                  l_name = 'l_%s' % selector.listens_to
                  return [cell for cell in self.cells.value() if hasattr(cell, l_name) and callable(getattr(cell, l_name))]
              else:
                  raise "unkown selector %s" % str(selector)
        elif (type(selector) == type('') and selector == 'all'):
              return self.cells.values()
        else:
              raise 'selector %s not implemented yet ' % str(selector)

    def emit_selector(self, event):
        return self.emit(event, self.CellsBySelector(event.get('selector', 'all')))

    def emit(self, event, py_cells):
        l_name = 'l_%s' % event['type']
        for cell in [cell for cell in py_cells if hasattr(cell, l_name)]:
            listener = getattr(cell, l_name)
            if callable(listener):
                listener(event)

if not 'cell_collection' in locals():
    cell_collection = CellCollection('py')


class Cell(object):
  """Docstring for Cell. """

  def call_soon(*kargs, **kwargs):
      cell_collection.asyncio_loop.call_soon(*kargs, **kwargs)

  def __init__(self):
      self.id = "%s:%d" % (cell_collection.prefix, cell_collection.id())
      cell_collection.cells[self.id] = self
      self.requests = {}

  def __reply_event(self, event, reply_event):
    reply_event['type'] = 'reply'
    reply_event['sender'] = self.id
    reply_event['selector'] = {'id': event['reply_to']}
    if 'request_id' in event:
      reply_event['request_id'] = event['request_id']
    return reply_event

  def reply_now(self, event, r):
      event['results'].append(self.__reply_event(event, {'result':  r}))

  def reply_error_now(self, event, r):
      event['results'].append(self.__reply_event(event, {'error':  r}))

  def async_reply(self, event, r):
    cells.emit(self.__reply_event(event, {'result': r} ))

  def async_reply_error(self, event, r):
    cells.emit(self.__reply_event(event, {'error': r} ))

  def kill(self):
      del cell_collection.cells[self.id]
      cells.emit({'sender': self.id, 'type': 'killed'})

  # ASK IMPLEMENTATION
  def cancel_request(self, request_id):
      request = self.requests.pop(request_id, None)
      if request == None:
          return
      for id in request.waiting_for.keys():
        cells.emit({'type': 'cancel_request', 'reuqest_id': request_id}, {'id': id})

  def cancel_ask(self, cb, event, request = {}):
      """ See viml.vim """
      for k in self.requests.keys():
        i = self.requests[k]
        if has_key(i,'type') and get(i, 'type') == request.type:
            self.cancel_request(k)
      self.ask(cb, event, request)

  async def ask_iter(self, event, request = {}):
    event['request_id'] = cell_collection.id()
    event['reply_to'] = self.id

    request['event'] = event
    request['replies_to_be_waited_for'] = {}
    request['cancel'] = 0
    request['waiting_for'] = {}
    request['queue'] = asyncio.Queue(maxsize = 1)

    cells.emit(event)

    print('yielding from event.results')
    for r in event['results']:
        yield r

    for wait_for_id in event['wait_for']:
        if wait_for_id in request['replies_to_be_waited_for']:
            print('yielding from replies_to_be_waited_for')
            yield request['replies_to_be_waited_for'].pop(wait_for_id)
        else:
            request['waiting_for'][wait_for_id] = 1

    while len(request['waiting_for']) > 0:
        print('yielding from waiting_for')
        print(request['queue'].qsize())
        print("waiting for %s" % str(request['waiting_for']))
        r = await request['queue'].get()
        yield r

  def l_reply(self, event):
      if not 'sender' in event:
          raise Exception('received reply missing sender key')
      request_id = event['request_id']

      request = self.requests[request_id]

      if event['wait_for_id'] in request['waiting_for']:
          request['waiting_for'].pop(event['wait_for_id'])

          for wait_for in event.get('wait_for', []):
              if wait_for in request['replies_to_be_waited_for']:
                  print("putitng")
                  request['queue'].put(request['replies_to_be_waited_for'].pop(wait_for))
              else:
                request['waiting_for'][wait_for] = 1
          if 'result' in event or 'error' in event:
              request['results'].append(event)
      else:
            request['replies_to_be_waited_for'][event['wait_for_id']] = event

class CellPy(Cell):
    """ cell implementing basic api for the cell collection """

    def l_cell_collections(self, event):
        self.reply_now(event, {'prefix': cell_collection.prefix, 'details': 'default Python cell collection'})

    def l_emit(self, event):
        cell_collection.emit_selector(event['event'])

    def l_cell_kill(self, event):
        for c in cell_collection.CellsBySelector(event['selector']):
            c.kill()

    def l_cell_list(self, event):
        self.reply_now(event, [x.id for x in  cell_collection.CellsBySelector(event.get('selector', 'all'))])

    def l_cell_new_by_name(self, event):
        if event.get('network', cell_collection.prefix) != cell_collection.prefix:
            return
        module_and_class = event['name']
        i = __import(event[module_and_class[0:-2]])
        cell = get(i, event[module_and_class[-1]])(*event.get('args', []), **event.get('kargs', {}))
        # TODO reply

class CellPyEventToVim(Cell):
    """ Events Python -> Vim
        See cells#viml#vim8_VimEventToPy for Vim -> Python
    """

    def __init__(self):
        super(CellPyEventToVim, self).__init__()

    def l_emit(self, event):
        if event['event']['origin_network'] == cell_collection.prefix:
            import vim
            import cells.util
            event_ = copy.copy(event['event'])
            for k in ['results', 'wait_for']:
                if k in event_:
                    event_[k] = []

            cells.util.to_vim(event_)
            event_ = vim.eval('cells#util#EmitReturn(g:to_vim)')

            for k in ['results', 'wait_for']:
                if k in event_:
                    event['event'][k] += event_[k]
