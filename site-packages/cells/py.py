# Python implementation
import copy
import cells

if not 'cells' in locals():
    cells = {}

class CellCollection:
    """Events will be sent to the cells contained in this collection"""

    def __init__(self, prefix):
        """@todo: to be defined1. """
        self.prefix = prefix
        self.cells = {}
        self.next_id = 0

    def id(self):
        self.next_id += 1
        return self.next_id

    def CellsBySelector(self, selector):
        """ select cells within cells """
        if (type(selector) == type({})):
              if  'id' in selector:
                  if selector['id'] in self.cells:
                      return cells[selector['id']]
                  else:
                      return []
              elif 'listens_to' in selector:
                  l_name = 'l_%s' % selector.listens_to
                  return [cell for cell in self.cells.value() if hasattr(cell, l_name) and callable(getattr(cell, l_name))]
              else:
                  raise "unkown selector %s" % str(selector)
        elif (type(selector) == type('') and selector == 'all'):
              return self.cells.values()
        else:
              raise 'selector %s not implemented yet ' % str(selector)

    def emit_selector(self, event):
        return self.emit(event, self.CellsBySelector(event.get('selector', 'all')))

    def emit(self, event, py_cells):
        l_name = 'l_%s' % event['type']
        for cell in [cell for cell in py_cells if hasattr(cell, l_name)]:
            listener = getattr(cell, l_name)
            if callable(listener):
                listener(event)

if not 'cell_collection' in locals():
    cell_collection = CellCollection('py')


class Cell(object):
  """Docstring for Cell. """

  def __init__(self):
      self.id = cell_collection.id()
      cell_collection.cells[self.id] = self


  def __reply_event(self, event, reply_event):
    reply_event['type'] = 'reply'
    reply_event['sender'] = self.id
    reply_event['selector'] = {'id': event['reply_to']}
    if 'request_id' in event:
      reply_event['request_id'] = event['request_id']
    return reply_event

  def reply_now(self, event, r):
      event['results'].append(self.__reply_event(event, {'result':  r}))

  def reply_error_now(self, event, r):
      event['results'].append(self.__reply_event(event, {'error':  r}))

  def async_reply(self, event, r):
    cells.emit(self.__reply_event(event, {'result': r} ))

  def async_reply_error(self, event, r):
    cells.emit(self.__reply_event(event, {'error': r} ))

  def kill(self):
      del cell_collection.cells[self.id]
      cells.emit({'sender': self.id, 'type': 'killed'})

class CellPy(Cell):
    """ cell implementing basic api for the cell collection """

    def l_cell_collections(self, event):
        self.reply_now(event, {'prefix': cell_collection.prefix, 'details': 'default Python cell collection'})

    def l_emit(self, event):
        cell_collection.emit_selector(event['event'])

    def l_cell_kill(self, event):
        for c in cell_collection.CellsBySelector(event['selector']):
            c.kill()

    def l_cell_list(self, event):
        self.reply_now(event, [x.id for x in  cell_collection.CellsBySelector(event['selector'])])


class CellPyEventToVim(Cell):
    """ Events Python -> Vim
        See cells#viml#vim8_VimEventToPy for Vim -> Python
    """

    def __init__(self):
        super(CellPyEventToVim, self).__init__()

    def l_emit(self, event):
        if event['event']['origin_network'] == cell_collection.prefix:
            import vim
            # print 'run: cells#viml#emit_selector(%s, %s)' % (str(event['event']), str(event['selector']))
            import cells.util
            event_ = copy.copy(event['event'])
            for k in ['results', 'wait_for']:
                if k in event_:
                    event_[k] = []

            cells.util.to_vim(event_)
            event_ = vim.eval('cells#util#EmitReturn(g:to_vim)')
            print(str(event_))

            for k in ['results', 'wait_for']:
                if k in event_:
                    event['event'][k] += event_[k]
