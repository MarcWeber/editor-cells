#!/usr/bin/env
# cells API using implementation at cells_py
import asyncio
from cells.py import cell_collection

def emit(event):

  reply_by = None

  if 'reply_to' in event:
    event['wait_for'] = event.get('wait_for', [])

    reply_by = 'result'

    def future_result(sender):
        wait_for_id = 'py-wait-for-%d' % cell_collection.id()
        event['wait_for'].append(wait_for_id)
        event['results']  = event.get('results', [])

        async def wait_for_result(coroutine):
            print("awaiting coroutine")
            r = await coroutine
            print("done awaiting coroutine")
            if reply_by == 'event':
                reply_event = []
                reply_event['type'] = 'reply'
                reply_event['sender'] = sender
                reply_event['wait_for_id'] = wait_for_id
                reply_event['selector'] = {'id': event['reply_to']}
                reply_event['result'] = r
                emit(reply_event)
            else:
                event['results'].append(r)

        return wait_for_result

    print("XXX")
    event['future_result'] = future_result

  if not 'origin_network' in event:
    event['origin_network'] = cell_collection.prefix
  cell_collection.emit_selector({'type': 'emit', 'event': event})

  if 'reply_to' in event:
    reply_by = 'event'

def kill(selector):
  emit({'type': 'killcells', 'selector': selector})

def log(lines):
  emit({'type': 'log', 'lines': lines})

def do_threadsafe(lambda_):
    cell_collection.asyncio_loop.call_soon_threadsafe(lambda_)
