# Python implementation
import copy
import cells
from cells.debug import debug_str

if not 'cells' in locals():
    cells = {}

class CellCollection:
    """Events will be sent to the cells contained in this collection"""

    def __init__(self, prefix):
        """@todo: to be defined1. """
        self.prefix = prefix
        self.cells = {}
        self.next_id = 0

    def id(self):
        self.next_id += 1
        return self.next_id

    def CellsBySelector(self, selector):
        """ select cells within cells """
        if (type(selector) == type({})):
              if  'id' in selector:
                  if selector['id'] in self.cells:
                      return [self.cells[selector['id']]]
                  else:
                      return []
              elif 'ids' in selector:
                  return [self.cells[id] for id in selector['ids'] if id in self.cells]
              elif 'listens_to' in selector:
                  l_name = 'l_%s' % selector.listens_to
                  return [cell for cell in self.cells.value() if hasattr(cell, l_name) and callable(getattr(cell, l_name))]
              else:
                  raise "unkown selector %s" % str(selector)
        elif (type(selector) == type('') and selector == 'all'):
              return self.cells.values()
        else:
              raise 'selector %s not implemented yet ' % str(selector)

    def emit_selector(self, event):
        return self.emit(event, self.CellsBySelector(event.get('selector', 'all')))

    def emit(self, event, py_cells):
        l_name = 'l_%s' % event['type']
        for cell in [cell for cell in py_cells if hasattr(cell, l_name)]:
            listener = getattr(cell, l_name)
            if callable(listener):
                listener(event)

if not 'cell_collection' in locals():
    cell_collection = CellCollection('py')


class Cell(object):
  """Docstring for Cell. """

  def __init__(self):
      self.id = "%s:%d" % (cell_collection.prefix, cell_collection.id())
      cell_collection.cells[self.id] = self
      self.requests = {}

  def __reply_event(self, event, reply_event):
    reply_event['type'] = 'reply'
    reply_event['sender'] = self.id
    reply_event['selector'] = {'id': event['reply_to']}
    if 'request_id' in event:
      reply_event['request_id'] = event['request_id']
    return reply_event

  def reply_now(self, event, r):
      event['results'].append(self.__reply_event(event, {'result':  r}))

  def reply_error_now(self, event, r):
      event['results'].append(self.__reply_event(event, {'error':  r}))

  def async_reply(self, event, wait_for_id, r):
      cells.emit(self.__reply_event(event, {'result': r, 'wait_for_id': wait_for_id} ))

  def async_reply_error(self, event, wait_for_id, r):
      cells.emit(self.__reply_event(event, {'error': r, 'wait_for_id': wait_for_id} ))

  def kill(self):
      del cell_collection.cells[self.id]
      cells.emit({'sender': self.id, 'type': 'killed'})

  # ASK IMPLEMENTATION
  def cancel_request(self, request_id):
      request = self.requests.pop(request_id, None)
      if request == None:
          return
      for id in request.waiting_for.keys():
        cells.emit({'type': 'cancel_request', 'reuqest_id': request_id}, {'id': id})

  def cancel_ask(self, cb, event, request = {}):
      """ See viml.vim """
      for k in self.requests.keys():
        i = self.requests[k]
        if has_key(i,'type') and get(i, 'type') == request.type:
            self.cancel_request(k)
      self.ask(cb, event, request)

  def ask(self, cb, event, request = {}):
    """ see viml.vim """
    debug_str("ASKASK in %s" % traceback.format_exc())
    request['cb'] = cb
    request['event'] = event

    request['replies_to_be_waited_for'] = {}
    request['cancel'] = 0
    request['waiting_for'] = {}

    event['request_id'] = cell_collection.id()
    event['reply_to'] = self.id

    self.requests[request['event']['request_id']] = request

    cells.emit(event)
    request['results'] = event['results']
    for cell_id in event['wait_for']:
        if cell_id in request['replies_to_be_waited_for']:
            request.results.append(request['replies_to_be_waited_for'].pop(cell_id))
        else:
            request['waiting_for'][cell_id] = 1
    self.__check_request_finished(request)
    event['request_id']

  def __check_request_finished(self, request):
      if len(request['waiting_for']) == 0 and len(request['replies_to_be_waited_for']) == 0:
          self.requests.pop(request['event']['request_id'])
          if not request['cancel']:
              request['results_good'] = [x['result'] for x in request['results'] if 'result' in x]
              request['errors']       = [x['error']  for x in request['results'] if 'error' in x]
              getattr(self, request['cb'])(request)


  def l_reply(self, event):
      request_id = event['request_id']

      request = self.requests[request_id]

      if event.sender in request['waiting_for']:
          request['waiting_for'].pop(event['sender'])

          for cell_id in event.get('wait_for', []):
              if cell_id in request['replies_to_be_waited_for']:
                  equest.results.append(request['replies_to_be_waited_for'].pop(cell_id))
              else:
                request['waiting_for'][cell_id] = 1
          if 'result' in event or 'error' in event:
              request['results'].append(event)
          if 'results' in event:
              for r in event['results']:
                  request['results'].append(r)

      else:
            request['replies_to_be_waited_for'][event['sender']] = event

      self.__check_request_finished(request)

class CellPy(Cell):
    """ cell implementing basic api for the cell collection """

    def l_cell_collections(self, event):
        self.reply_now(event, {'prefix': cell_collection.prefix, 'details': 'default Python cell collection'})

    def l_emit(self, event):
        cell_collection.emit_selector(event['event'])

    def l_cell_kill(self, event):
        for c in cell_collection.CellsBySelector(event['selector']):
            c.kill()

    def l_cell_list(self, event):
        self.reply_now(event, [x.id for x in  cell_collection.CellsBySelector(event['selector'])])

    def l_cell_new_by_name(self, event):
        raise Exception("abc")
        if event.get('network', cell_collection.prefix) != cell_collection.prefix:
            return
        module_and_class = event['name']
        i = __import(event[module_and_class[0:-2]])
        cell = get(i, event[module_and_class[-1]])(*event.get('args', []), **event.get('kwargs', {}))
        self.reply_now(event, {'id': cell.id})

class CellPyEventToVim(Cell):
    """ Events Python -> Vim
        See cells#viml#vim8_VimEventToPy for Vim -> Python
    """

    def __init__(self):
        super(CellPyEventToVim, self).__init__()

    def l_emit(self, event):
        if event['event']['origin_network'] == cell_collection.prefix:
            import vim
            import cells.util
            event_ = copy.copy(event['event'])
            for k in ['results', 'wait_for']:
                if k in event_:
                    event_[k] = []

            cells.util.to_vim(event_)
            event_ = vim.eval('cells#util#EmitReturn(g:to_vim)')

            for k in ['results', 'wait_for']:
                if k in event_:
                    event['event'][k] += event_[k]
