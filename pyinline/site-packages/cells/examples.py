import cells
from cells.py import Cell
import re
import math
import glob
import os.path

class CompletionBasedOnFiles(Cell):
    """provide completions based on files"""

    def __init__(self):
        super(CompletionBasedOnFiles, self).__init__()

    # TODO remove  this and replace it by an event based system
    def l_completions(self, event):
        """ sample implemenattion illustrating how word completion within a buffer
            can be done showing words nearby the cursor rated higher
            implementing multiple match_types."""

        event['wait_for'].append(self.id)
        self.ask('with_buffers', {'type': 'editor_buffers'}, {'original_event': event}) # TODO: use a promise library !?

    def with_buffers(self, request):
        r = {'original_event' : request['original_event']}

        files_open_in_vim = []
        for result in request['results_good']:
            files_open_in_vim += [x['filepath'] for x in result['buffers']]
        r['files_open_in_vim'] = files_open_in_vim

        self.ask('with_files', {'type': 'project_files'}, r) # TODO: use a promise library !?

    def with_files(self, request):
        oe = request['original_event']
        self.async_reply(oe, self.id, [])
        files_open_in_vim = request['files_open_in_vim']

        rest = set(sum(request['results_good'], [])) - set(files_open_in_vim)
        words_ = re.split('[ \t\r\n.{}()<>\'"]', oe['event']['line_split_at_cursor'][0])
        word_before_cursor = words_[-1]

        words = {}

        def add(word, certainity):
            if word in words:
                words[word]['count'] += 1
                words[word]['w'] = max([words[word]['w'], certainity])
                # + 0.1 if words are used very often then its more like that they will be used
            else:
                words[word] = {'word': word, 'w': certainity, 'description': word+' (py)', 'count': 0}

        linenr = 1
        nearby_cursor_lines = 100.0
        import vim

        match_str = cells.util.match_regex_str_by_types(word_before_cursor, oe['event']['match_types'])
        re_match = re.compile('^'+match_str)

        for line in vim.current.buffer[:]:
            for w in line.split(' '):
                if w == word_before_cursor or w == '' or not re_match.match(w):
                    continue
                line_diff = linenr - int(oe['event']['position'][1])
                if abs(line_diff) > nearby_cursor_lines:
                    certainity = 1
                else:
                    # words in lines nearby cursor are more important ..
                    certainity = 1+ (1.0 - abs(line_diff) / nearby_cursor_lines)
                    if linenr > int(oe['event']['position'][1]):
                        # lines below cursor are less important than above cursor
                        certainity = math.sqrt(certainity)
                add(w, 200 + certainity)
            linenr += 1

        find_all = cells.util.CompletionWordsFromStr(word_before_cursor, oe['event']['match_types'])
        re_last_upper_str = cells.util.match_regex_str(word_before_cursor, 'last_upper')
        re_last_upper     = re.compile(re_last_upper_str) if re_last_upper_str != None else None

        for file in list(rest):
            if (os.path.isfile(file)):
                for word in find_all.all(open(file,'r').read()):
                    add(word, 10 if re_last_upper != None and re_last_upper.match(word) else 0.5)

        for file in list(files_open_in_vim):
            if (os.path.isfile(file)):
                for word in find_all.all(open(file,'r').read()):
                    add(word, 10 if re_last_upper != None and re_last_upper.match(word) else 1)
            if len(words) > 100000:
                break

        completions = list(words.values()) # cells.util.match_by_type(words.values(), word_before_cursor, oe['event']['match_types'])

        # normalizing results, these completions provide high noise

        if len(completions) == 0:
            self.async_reply(oe, self,id, [])
            return

        for w in completions:
            w['w'] = w['w'] + math.atan(w['count'] / 10) # so result should should be somwhere between 1 and 2

        maxv = max([x['w'] for x in completions])
        for w in completions:
            w['w'] = w['w'] / maxv

        completions.sort(key = lambda a: -a['w']) # so results should be less than 1
        completions = completions[0:int(oe['event']['limit'])]
        self.async_reply(oe, self.id, [{ 'column': int(oe['event']['position'][2]) - len(word_before_cursor), 'completions' : completions }])

class Completion(Cell):
    """Docstring for CompletionBasedOnOpenBuffers. """

    def l_completions(self, event):
        """ sample implemenattion illustrating how word completion within a buffer
            can be done showing words nearby the cursor rated higher
            implementing multiple match_types."""
        import vim

        words_ = re.split('[ \t\r\n.{}()<>\'"]', event['event']['line_split_at_cursor'][0])
        word_before_cursor = words_[-1]

        words = {}
        linenr = 1

        nearby_cursor_lines = 100.0

        for line in vim.current.buffer[:]:
            for w in line.split(' '):
                if w == word_before_cursor or w == '':
                    continue
                line_diff = linenr - int(event['event']['position'][1])
                if abs(line_diff) > nearby_cursor_lines:
                    certainity = 1
                else:
                    # words in lines nearby cursor are more important ..
                    certainity = 1+ (1.0 - abs(line_diff) / nearby_cursor_lines)
                    if linenr > int(event['event']['position'][1]):
                        # lines below cursor are less important than above cursor
                        certainity = math.sqrt(certainity)
                words[w] = {'word': w, 'w': certainity, 'description': w+' (py)'}
            linenr += 1

        completions = cells.util.match_by_type(words.values(), word_before_cursor, event['event']['match_types'])
        self.reply_now(event, [{ 'column': int(event['event']['position'][2]) - len(word_before_cursor), 'completions' : completions }])


class Mappings(Cell):
    """Tell the editor about some mappings"""

    def __init__(self):
        super(Mappings, self).__init__()
        cells.emit({'type': 'mappings_changed', 'sender': self.id})

    def l_mappigns(self, event):
        mappings = []
        mappings.append({'scope': 'global',                 'mode': 'normal', 'lhs': '<f5>', 'emit_event': {'type': 'do_echo', 'text': 'scope=g f5 was hit, from pyhton'}})
        mappings.append({'scope': 'bufnr:4',                'mode': 'normal', 'lhs': '<f6>', 'emit_event': {'type': 'do_echo', 'text': 'scope=g f6 was hit, from pyhton'}})
        mappings.append({'scope': 'filepath_regex:\.js$',   'mode': 'normal', 'lhs': '<f7>', 'emit_event': {'type': 'do_echo', 'text': 'scope=g f7 was hit, from pyhton'}})
        self.reply_now(event, mappings)

    def l_do_echo(self, event):
        cells.Log(event.text)

class Signs(Cell):

    def __init__(self):
        super(Signs, self).__init__()
        cells.emit({'type': 'signs_changed', 'sender': self.id})

    def l_signs(self, event):
         self.reply_now(event, [{'bufnr': 1, 'name': 'test', 'category' : 'test', 'definition': 'text=-', 'signs': [{'line': 2, 'comment': 'comment about sign - on line 2, from python' }]}])

class Quickfix(Cell):

    def __init__(self):
        super(Quickfix, self).__init__()
        cells.emit({'type': 'quickfix_list_available', 'sender': self.id})

    def l_quickfix_list(self, event):
        self.reply_now(event, {'truncated': False, 'list': [{'bufnr': 1, 'text': 'error', 'col': 10, 'lnum': 5, 'type' : 'E'}]})


